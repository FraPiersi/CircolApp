<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/circolapp/AddEventoViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/circolapp/AddEventoViewModel.kt" />
              <option name="updatedContent" value="package com.example.circolapp.viewmodel&#10;&#10;import android.app.Application&#10;import android.util.Log&#10;import androidx.lifecycle.AndroidViewModel&#10;import androidx.lifecycle.LiveData&#10;import androidx.lifecycle.MutableLiveData&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.circolapp.model.Evento&#10;import com.google.firebase.auth.FirebaseAuth&#10;import com.google.firebase.firestore.FirebaseFirestore&#10;import com.google.firebase.firestore.FieldValue&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.tasks.await&#10;import java.util.*&#10;&#10;sealed class AddEventoEvent {&#10;    object EventoSaved : AddEventoEvent()&#10;    data class Error(val message: String) : AddEventoEvent()&#10;}&#10;&#10;data class AddEventoState(&#10;    val isLoading: Boolean = false,&#10;    val errorMessage: String? = null&#10;)&#10;&#10;class AddEventoViewModel(application: Application) : AndroidViewModel(application) {&#10;&#10;    private val db = FirebaseFirestore.getInstance()&#10;    private val auth = FirebaseAuth.getInstance()&#10;&#10;    // Campi del form&#10;    val eventoNome = MutableLiveData&lt;String&gt;()&#10;    val eventoDescrizione = MutableLiveData&lt;String&gt;()&#10;    val eventoData = MutableLiveData&lt;String&gt;()&#10;    val eventoOra = MutableLiveData&lt;String&gt;()&#10;    val eventoLuogo = MutableLiveData&lt;String&gt;()&#10;    val eventoQuota = MutableLiveData&lt;String&gt;()&#10;&#10;    private val _state = MutableLiveData(AddEventoState())&#10;    val state: LiveData&lt;AddEventoState&gt; get() = _state&#10;&#10;    private val _event = MutableLiveData&lt;AddEventoEvent?&gt;()&#10;    val event: LiveData&lt;AddEventoEvent?&gt; get() = _event&#10;&#10;    fun saveEvento() {&#10;        val nome = eventoNome.value?.trim()&#10;        val descrizione = eventoDescrizione.value?.trim()&#10;        val data = eventoData.value?.trim()&#10;        val ora = eventoOra.value?.trim()&#10;        val luogo = eventoLuogo.value?.trim()&#10;        val quotaStr = eventoQuota.value?.trim()&#10;&#10;        if (nome.isNullOrEmpty() || descrizione.isNullOrEmpty() || &#10;            data.isNullOrEmpty() || ora.isNullOrEmpty() || luogo.isNullOrEmpty()) {&#10;            _event.value = AddEventoEvent.Error(&quot;Tutti i campi sono obbligatori&quot;)&#10;            return&#10;        }&#10;&#10;        val quota = quotaStr?.toDoubleOrNull()&#10;        if (quotaStr.isNullOrEmpty() || quota == null || quota &lt; 0) {&#10;            _event.value = AddEventoEvent.Error(&quot;Quota non valida&quot;)&#10;            return&#10;        }&#10;&#10;        updateState { it.copy(isLoading = true) }&#10;&#10;        viewModelScope.launch {&#10;            try {&#10;                val evento = Evento(&#10;                    nome = nome,&#10;                    descrizione = descrizione,&#10;                    data = data,&#10;                    ora = ora,&#10;                    luogo = luogo,&#10;                    quota = quota,&#10;                    dataCreazione = Date(),&#10;                    partecipanti = emptyList()&#10;                )&#10;&#10;                db.collection(&quot;eventi&quot;).add(evento).await()&#10;&#10;                updateState { it.copy(isLoading = false) }&#10;                _event.value = AddEventoEvent.EventoSaved&#10;                &#10;                // Pulisci i campi dopo il salvataggio&#10;                clearForm()&#10;                &#10;            } catch (e: Exception) {&#10;                Log.e(&quot;AddEventoVM&quot;, &quot;Errore salvataggio evento&quot;, e)&#10;                updateState { it.copy(isLoading = false) }&#10;                _event.value = AddEventoEvent.Error(&quot;Errore nel salvataggio: ${e.message}&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun clearForm() {&#10;        eventoNome.value = &quot;&quot;&#10;        eventoDescrizione.value = &quot;&quot;&#10;        eventoData.value = &quot;&quot;&#10;        eventoOra.value = &quot;&quot;&#10;        eventoLuogo.value = &quot;&quot;&#10;        eventoQuota.value = &quot;&quot;&#10;    }&#10;&#10;    fun onEventHandled() {&#10;        _event.value = null&#10;    }&#10;&#10;    fun clearError() {&#10;        updateState { it.copy(errorMessage = null) }&#10;    }&#10;&#10;    private fun updateState(updateAction: (AddEventoState) -&gt; AddEventoState) {&#10;        _state.value = updateAction(_state.value ?: AddEventoState())&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/circolapp/DettaglioProdottoViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/circolapp/DettaglioProdottoViewModel.kt" />
              <option name="updatedContent" value="package com.example.circolapp.viewmodel&#10;&#10;import android.app.Application&#10;import android.util.Log&#10;import androidx.lifecycle.AndroidViewModel&#10;import androidx.lifecycle.LiveData&#10;import androidx.lifecycle.MutableLiveData&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.circolapp.model.Product&#10;import com.example.circolapp.model.Ordine&#10;import com.example.circolapp.model.UserRole&#10;import com.google.firebase.auth.FirebaseAuth&#10;import com.google.firebase.firestore.FirebaseFirestore&#10;import com.google.firebase.firestore.FieldValue&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.tasks.await&#10;import java.util.*&#10;&#10;data class DettaglioProdottoState(&#10;    val product: Product? = null,&#10;    val isLoading: Boolean = false,&#10;    val errorMessage: String? = null,&#10;    val currentUserRole: UserRole? = null,&#10;    val orderSuccessMessage: String? = null&#10;)&#10;&#10;class DettaglioProdottoViewModel(application: Application) : AndroidViewModel(application) {&#10;&#10;    private val db = FirebaseFirestore.getInstance()&#10;    private val auth = FirebaseAuth.getInstance()&#10;&#10;    private val _state = MutableLiveData(DettaglioProdottoState())&#10;    val state: LiveData&lt;DettaglioProdottoState&gt; get() = _state&#10;&#10;    fun initialize(product: Product) {&#10;        _state.value = _state.value?.copy(product = product, isLoading = true)&#10;        loadUserRole()&#10;    }&#10;&#10;    private fun loadUserRole() {&#10;        viewModelScope.launch {&#10;            try {&#10;                val currentUser = auth.currentUser&#10;                if (currentUser != null) {&#10;                    val userDoc = db.collection(&quot;utenti&quot;).document(currentUser.uid).get().await()&#10;                    val roleString = userDoc.getString(&quot;ruolo&quot;)&#10;                    val role = roleString?.let { UserRole.valueOf(it.uppercase()) }&#10;                    &#10;                    updateState { it.copy(currentUserRole = role, isLoading = false) }&#10;                } else {&#10;                    updateState { it.copy(isLoading = false, errorMessage = &quot;Utente non autenticato&quot;) }&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;DettaglioProdottoVM&quot;, &quot;Errore caricamento ruolo utente&quot;, e)&#10;                updateState { it.copy(isLoading = false, errorMessage = &quot;Errore caricamento dati utente&quot;) }&#10;            }&#10;        }&#10;    }&#10;&#10;    fun orderProduct(additionalRequests: String) {&#10;        val product = _state.value?.product&#10;        val currentUser = auth.currentUser&#10;        &#10;        if (product == null || currentUser == null) {&#10;            updateState { it.copy(errorMessage = &quot;Dati mancanti per completare l'ordine&quot;) }&#10;            return&#10;        }&#10;&#10;        updateState { it.copy(isLoading = true) }&#10;&#10;        viewModelScope.launch {&#10;            try {&#10;                val ordine = Ordine(&#10;                    uidUtente = currentUser.uid,&#10;                    prodottoId = product.id ?: &quot;&quot;,&#10;                    nomeProdotto = product.nome,&#10;                    importo = product.importo,&#10;                    richiesteAggiuntive = additionalRequests,&#10;                    dataOrdine = Date(),&#10;                    stato = &quot;in_attesa&quot;&#10;                )&#10;&#10;                db.collection(&quot;ordinazioni&quot;).add(ordine).await()&#10;                &#10;                updateState { &#10;                    it.copy(&#10;                        isLoading = false, &#10;                        orderSuccessMessage = &quot;Ordine effettuato con successo!&quot;,&#10;                        errorMessage = null&#10;                    ) &#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;DettaglioProdottoVM&quot;, &quot;Errore creazione ordine&quot;, e)&#10;                updateState { &#10;                    it.copy(&#10;                        isLoading = false, &#10;                        errorMessage = &quot;Errore nell'effettuare l'ordine: ${e.message}&quot;&#10;                    ) &#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    fun clearMessages() {&#10;        updateState { it.copy(errorMessage = null, orderSuccessMessage = null) }&#10;    }&#10;&#10;    private fun updateState(updateAction: (DettaglioProdottoState) -&gt; DettaglioProdottoState) {&#10;        _state.value = updateAction(_state.value ?: DettaglioProdottoState())&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/circolapp/FeedbackListViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/circolapp/FeedbackListViewModel.kt" />
              <option name="updatedContent" value="package com.example.circolapp.viewmodel&#10;&#10;import android.app.Application&#10;import android.util.Log&#10;import androidx.lifecycle.AndroidViewModel&#10;import androidx.lifecycle.LiveData&#10;import androidx.lifecycle.MutableLiveData&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.circolapp.model.Feedback&#10;import com.google.firebase.auth.FirebaseAuth&#10;import com.google.firebase.firestore.FirebaseFirestore&#10;import com.google.firebase.firestore.Query&#10;import com.google.firebase.firestore.ktx.toObjects&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.tasks.await&#10;&#10;data class FeedbackListState(&#10;    val feedbacks: List&lt;Feedback&gt; = emptyList(),&#10;    val isLoading: Boolean = false,&#10;    val errorMessage: String? = null&#10;)&#10;&#10;class FeedbackListViewModel(application: Application) : AndroidViewModel(application) {&#10;&#10;    private val db = FirebaseFirestore.getInstance()&#10;    private val auth = FirebaseAuth.getInstance()&#10;&#10;    private val _state = MutableLiveData(FeedbackListState())&#10;    val state: LiveData&lt;FeedbackListState&gt; get() = _state&#10;&#10;    init {&#10;        loadFeedbacks()&#10;    }&#10;&#10;    private fun loadFeedbacks() {&#10;        _state.value = _state.value?.copy(isLoading = true)&#10;        &#10;        viewModelScope.launch {&#10;            try {&#10;                val feedbacksSnapshot = db.collection(&quot;feedback&quot;)&#10;                    .orderBy(&quot;dataCreazione&quot;, Query.Direction.DESCENDING)&#10;                    .get()&#10;                    .await()&#10;&#10;                val feedbacks = feedbacksSnapshot.toObjects&lt;Feedback&gt;()&#10;                &#10;                updateState { &#10;                    it.copy(&#10;                        feedbacks = feedbacks,&#10;                        isLoading = false,&#10;                        errorMessage = null&#10;                    ) &#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;FeedbackListVM&quot;, &quot;Errore caricamento feedback&quot;, e)&#10;                updateState { &#10;                    it.copy(&#10;                        isLoading = false,&#10;                        errorMessage = &quot;Errore nel caricamento dei feedback: ${e.message}&quot;&#10;                    ) &#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    fun refreshFeedbacks() {&#10;        loadFeedbacks()&#10;    }&#10;&#10;    fun clearError() {&#10;        updateState { it.copy(errorMessage = null) }&#10;    }&#10;&#10;    private fun updateState(updateAction: (FeedbackListState) -&gt; FeedbackListState) {&#10;        _state.value = updateAction(_state.value ?: FeedbackListState())&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/circolapp/GestisciTessereViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/circolapp/GestisciTessereViewModel.kt" />
              <option name="updatedContent" value="package com.example.circolapp.viewmodel&#10;&#10;import android.app.Application&#10;import android.util.Log&#10;import androidx.lifecycle.AndroidViewModel&#10;import androidx.lifecycle.LiveData&#10;import androidx.lifecycle.MutableLiveData&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.circolapp.model.User&#10;import com.example.circolapp.model.TesseraRequest&#10;import com.google.firebase.auth.FirebaseAuth&#10;import com.google.firebase.firestore.FirebaseFirestore&#10;import com.google.firebase.firestore.ktx.toObjects&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.tasks.await&#10;&#10;data class GestisciTessereState(&#10;    val users: List&lt;User&gt; = emptyList(),&#10;    val tesseraRequests: List&lt;TesseraRequest&gt; = emptyList(),&#10;    val isLoading: Boolean = false,&#10;    val errorMessage: String? = null,&#10;    val successMessage: String? = null&#10;)&#10;&#10;class GestisciTessereViewModel(application: Application) : AndroidViewModel(application) {&#10;&#10;    private val db = FirebaseFirestore.getInstance()&#10;    private val auth = FirebaseAuth.getInstance()&#10;&#10;    private val _state = MutableLiveData(GestisciTessereState())&#10;    val state: LiveData&lt;GestisciTessereState&gt; get() = _state&#10;&#10;    init {&#10;        loadData()&#10;    }&#10;&#10;    private fun loadData() {&#10;        _state.value = _state.value?.copy(isLoading = true)&#10;        &#10;        viewModelScope.launch {&#10;            try {&#10;                // Carica utenti&#10;                val usersSnapshot = db.collection(&quot;utenti&quot;).get().await()&#10;                val users = usersSnapshot.toObjects&lt;User&gt;()&#10;&#10;                // Carica richieste tessere&#10;                val requestsSnapshot = db.collection(&quot;tessera_requests&quot;).get().await()&#10;                val requests = requestsSnapshot.toObjects&lt;TesseraRequest&gt;()&#10;&#10;                updateState { &#10;                    it.copy(&#10;                        users = users,&#10;                        tesseraRequests = requests,&#10;                        isLoading = false,&#10;                        errorMessage = null&#10;                    ) &#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;GestisciTessereVM&quot;, &quot;Errore caricamento dati&quot;, e)&#10;                updateState { &#10;                    it.copy(&#10;                        isLoading = false,&#10;                        errorMessage = &quot;Errore nel caricamento dei dati: ${e.message}&quot;&#10;                    ) &#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    fun approveRequest(requestId: String) {&#10;        viewModelScope.launch {&#10;            try {&#10;                db.collection(&quot;tessera_requests&quot;)&#10;                    .document(requestId)&#10;                    .update(&quot;stato&quot;, &quot;approvata&quot;)&#10;                    .await()&#10;&#10;                updateState { &#10;                    it.copy(successMessage = &quot;Richiesta approvata con successo&quot;) &#10;                }&#10;                loadData() // Ricarica i dati&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;GestisciTessereVM&quot;, &quot;Errore approvazione richiesta&quot;, e)&#10;                updateState { &#10;                    it.copy(errorMessage = &quot;Errore nell'approvazione: ${e.message}&quot;) &#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    fun rejectRequest(requestId: String) {&#10;        viewModelScope.launch {&#10;            try {&#10;                db.collection(&quot;tessera_requests&quot;)&#10;                    .document(requestId)&#10;                    .update(&quot;stato&quot;, &quot;rifiutata&quot;)&#10;                    .await()&#10;&#10;                updateState { &#10;                    it.copy(successMessage = &quot;Richiesta rifiutata&quot;) &#10;                }&#10;                loadData() // Ricarica i dati&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;GestisciTessereVM&quot;, &quot;Errore rifiuto richiesta&quot;, e)&#10;                updateState { &#10;                    it.copy(errorMessage = &quot;Errore nel rifiuto: ${e.message}&quot;) &#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    fun refreshData() {&#10;        loadData()&#10;    }&#10;&#10;    fun clearMessages() {&#10;        updateState { it.copy(errorMessage = null, successMessage = null) }&#10;    }&#10;&#10;    private fun updateState(updateAction: (GestisciTessereState) -&gt; GestisciTessereState) {&#10;        _state.value = updateAction(_state.value ?: GestisciTessereState())&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/circolapp/NotificheViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/circolapp/NotificheViewModel.kt" />
              <option name="updatedContent" value="package com.example.circolapp.viewmodel&#10;&#10;import android.app.Application&#10;import android.util.Log&#10;import androidx.lifecycle.AndroidViewModel&#10;import androidx.lifecycle.LiveData&#10;import androidx.lifecycle.MutableLiveData&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.circolapp.model.Notifica&#10;import com.google.firebase.auth.FirebaseAuth&#10;import com.google.firebase.firestore.FirebaseFirestore&#10;import com.google.firebase.firestore.Query&#10;import com.google.firebase.firestore.ktx.toObjects&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.tasks.await&#10;&#10;data class NotificheState(&#10;    val notifiche: List&lt;Notifica&gt; = emptyList(),&#10;    val isLoading: Boolean = false,&#10;    val errorMessage: String? = null&#10;)&#10;&#10;class NotificheViewModel(application: Application) : AndroidViewModel(application) {&#10;&#10;    private val db = FirebaseFirestore.getInstance()&#10;    private val auth = FirebaseAuth.getInstance()&#10;&#10;    private val _state = MutableLiveData(NotificheState())&#10;    val state: LiveData&lt;NotificheState&gt; get() = _state&#10;&#10;    init {&#10;        loadNotifiche()&#10;    }&#10;&#10;    private fun loadNotifiche() {&#10;        val currentUser = auth.currentUser&#10;        if (currentUser == null) {&#10;            updateState { &#10;                it.copy(&#10;                    isLoading = false,&#10;                    errorMessage = &quot;Utente non autenticato&quot;&#10;                ) &#10;            }&#10;            return&#10;        }&#10;&#10;        _state.value = _state.value?.copy(isLoading = true)&#10;        &#10;        viewModelScope.launch {&#10;            try {&#10;                val notificheSnapshot = db.collection(&quot;notifiche&quot;)&#10;                    .whereEqualTo(&quot;uidUtente&quot;, currentUser.uid)&#10;                    .orderBy(&quot;timestamp&quot;, Query.Direction.DESCENDING)&#10;                    .get()&#10;                    .await()&#10;&#10;                val notifiche = notificheSnapshot.toObjects&lt;Notifica&gt;()&#10;                &#10;                updateState { &#10;                    it.copy(&#10;                        notifiche = notifiche,&#10;                        isLoading = false,&#10;                        errorMessage = null&#10;                    ) &#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;NotificheVM&quot;, &quot;Errore caricamento notifiche&quot;, e)&#10;                updateState { &#10;                    it.copy(&#10;                        isLoading = false,&#10;                        errorMessage = &quot;Errore nel caricamento delle notifiche: ${e.message}&quot;&#10;                    ) &#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    fun markAsRead(notificaId: String) {&#10;        viewModelScope.launch {&#10;            try {&#10;                db.collection(&quot;notifiche&quot;)&#10;                    .document(notificaId)&#10;                    .update(&quot;letta&quot;, true)&#10;                    .await()&#10;&#10;                loadNotifiche() // Ricarica le notifiche&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;NotificheVM&quot;, &quot;Errore marcatura notifica come letta&quot;, e)&#10;                updateState { &#10;                    it.copy(errorMessage = &quot;Errore nell'aggiornamento: ${e.message}&quot;) &#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    fun deleteNotifica(notificaId: String) {&#10;        viewModelScope.launch {&#10;            try {&#10;                db.collection(&quot;notifiche&quot;)&#10;                    .document(notificaId)&#10;                    .delete()&#10;                    .await()&#10;&#10;                loadNotifiche() // Ricarica le notifiche&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;NotificheVM&quot;, &quot;Errore eliminazione notifica&quot;, e)&#10;                updateState { &#10;                    it.copy(errorMessage = &quot;Errore nell'eliminazione: ${e.message}&quot;) &#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    fun refreshNotifiche() {&#10;        loadNotifiche()&#10;    }&#10;&#10;    fun clearError() {&#10;        updateState { it.copy(errorMessage = null) }&#10;    }&#10;&#10;    private fun updateState(updateAction: (NotificheState) -&gt; NotificheState) {&#10;        _state.value = updateAction(_state.value ?: NotificheState())&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/circolapp/PagamentoViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/circolapp/PagamentoViewModel.kt" />
              <option name="updatedContent" value="package com.example.circolapp.viewmodel&#10;&#10;import android.app.Application&#10;import android.util.Log&#10;import androidx.lifecycle.AndroidViewModel&#10;import androidx.lifecycle.LiveData&#10;import androidx.lifecycle.MutableLiveData&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.circolapp.model.Ordine&#10;import com.google.firebase.auth.FirebaseAuth&#10;import com.google.firebase.firestore.FirebaseFirestore&#10;import com.google.firebase.firestore.FieldValue&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.tasks.await&#10;&#10;data class PagamentoState(&#10;    val ordine: Ordine? = null,&#10;    val saldoUtente: Double = 0.0,&#10;    val isLoading: Boolean = false,&#10;    val errorMessage: String? = null,&#10;    val paymentSuccessMessage: String? = null,&#10;    val insufficientFunds: Boolean = false&#10;)&#10;&#10;class PagamentoViewModel(application: Application) : AndroidViewModel(application) {&#10;&#10;    private val db = FirebaseFirestore.getInstance()&#10;    private val auth = FirebaseAuth.getInstance()&#10;&#10;    private val _state = MutableLiveData(PagamentoState())&#10;    val state: LiveData&lt;PagamentoState&gt; get() = _state&#10;&#10;    fun initialize(ordine: Ordine) {&#10;        _state.value = _state.value?.copy(ordine = ordine, isLoading = true)&#10;        loadUserBalance()&#10;    }&#10;&#10;    private fun loadUserBalance() {&#10;        val currentUser = auth.currentUser&#10;        if (currentUser == null) {&#10;            updateState { &#10;                it.copy(&#10;                    isLoading = false,&#10;                    errorMessage = &quot;Utente non autenticato&quot;&#10;                ) &#10;            }&#10;            return&#10;        }&#10;&#10;        viewModelScope.launch {&#10;            try {&#10;                val userDoc = db.collection(&quot;utenti&quot;).document(currentUser.uid).get().await()&#10;                val saldo = userDoc.getDouble(&quot;saldo&quot;) ?: 0.0&#10;                &#10;                val ordine = _state.value?.ordine&#10;                val insufficientFunds = ordine?.let { saldo &lt; it.importo } ?: false&#10;                &#10;                updateState { &#10;                    it.copy(&#10;                        saldoUtente = saldo,&#10;                        isLoading = false,&#10;                        insufficientFunds = insufficientFunds,&#10;                        errorMessage = null&#10;                    ) &#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;PagamentoVM&quot;, &quot;Errore caricamento saldo utente&quot;, e)&#10;                updateState { &#10;                    it.copy(&#10;                        isLoading = false,&#10;                        errorMessage = &quot;Errore nel caricamento del saldo: ${e.message}&quot;&#10;                    ) &#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    fun processPayment() {&#10;        val currentUser = auth.currentUser&#10;        val ordine = _state.value?.ordine&#10;        val saldo = _state.value?.saldoUtente&#10;        &#10;        if (currentUser == null || ordine == null || saldo == null) {&#10;            updateState { it.copy(errorMessage = &quot;Dati mancanti per completare il pagamento&quot;) }&#10;            return&#10;        }&#10;&#10;        if (saldo &lt; ordine.importo) {&#10;            updateState { &#10;                it.copy(&#10;                    errorMessage = &quot;Saldo insufficiente. Saldo attuale: €$saldo, Importo richiesto: €${ordine.importo}&quot;,&#10;                    insufficientFunds = true&#10;                ) &#10;            }&#10;            return&#10;        }&#10;&#10;        updateState { it.copy(isLoading = true) }&#10;&#10;        viewModelScope.launch {&#10;            try {&#10;                // Aggiorna il saldo dell'utente&#10;                db.collection(&quot;utenti&quot;)&#10;                    .document(currentUser.uid)&#10;                    .update(&quot;saldo&quot;, FieldValue.increment(-ordine.importo))&#10;                    .await()&#10;&#10;                // Registra la transazione nei movimenti&#10;                val movimento = hashMapOf(&#10;                    &quot;importo&quot; to -ordine.importo,&#10;                    &quot;descrizione&quot; to &quot;Pagamento per ${ordine.nomeProdotto}&quot;,&#10;                    &quot;data&quot; to FieldValue.serverTimestamp()&#10;                )&#10;&#10;                db.collection(&quot;utenti&quot;)&#10;                    .document(currentUser.uid)&#10;                    .update(&quot;movimenti&quot;, FieldValue.arrayUnion(movimento))&#10;                    .await()&#10;&#10;                // Aggiorna lo stato dell'ordine&#10;                db.collection(&quot;ordinazioni&quot;)&#10;                    .whereEqualTo(&quot;uidUtente&quot;, currentUser.uid)&#10;                    .whereEqualTo(&quot;prodottoId&quot;, ordine.prodottoId)&#10;                    .whereEqualTo(&quot;stato&quot;, &quot;in_attesa&quot;)&#10;                    .get()&#10;                    .await()&#10;                    .documents&#10;                    .firstOrNull()&#10;                    ?.reference&#10;                    ?.update(&quot;stato&quot;, &quot;completato&quot;)&#10;                    ?.await()&#10;&#10;                updateState { &#10;                    it.copy(&#10;                        isLoading = false,&#10;                        paymentSuccessMessage = &quot;Pagamento completato con successo!&quot;,&#10;                        saldoUtente = saldo - ordine.importo,&#10;                        errorMessage = null&#10;                    ) &#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;PagamentoVM&quot;, &quot;Errore processamento pagamento&quot;, e)&#10;                updateState { &#10;                    it.copy(&#10;                        isLoading = false,&#10;                        errorMessage = &quot;Errore nel processamento del pagamento: ${e.message}&quot;&#10;                    ) &#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    fun clearMessages() {&#10;        updateState { it.copy(errorMessage = null, paymentSuccessMessage = null) }&#10;    }&#10;&#10;    private fun updateState(updateAction: (PagamentoState) -&gt; PagamentoState) {&#10;        _state.value = updateAction(_state.value ?: PagamentoState())&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/circolapp/ProfiloViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/circolapp/ProfiloViewModel.kt" />
              <option name="updatedContent" value="package com.example.circolapp.viewmodel&#10;&#10;import android.app.Application&#10;import android.util.Log&#10;import androidx.lifecycle.AndroidViewModel&#10;import androidx.lifecycle.LiveData&#10;import androidx.lifecycle.MutableLiveData&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.circolapp.model.User&#10;import com.example.circolapp.model.UserRole&#10;import com.example.circolapp.model.Movimento&#10;import com.google.firebase.auth.FirebaseAuth&#10;import com.google.firebase.firestore.FirebaseFirestore&#10;import com.google.firebase.firestore.ktx.toObject&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.tasks.await&#10;&#10;data class ProfiloState(&#10;    val user: User? = null,&#10;    val movimenti: List&lt;Movimento&gt; = emptyList(),&#10;    val isLoading: Boolean = false,&#10;    val errorMessage: String? = null,&#10;    val successMessage: String? = null&#10;)&#10;&#10;class ProfiloViewModel(application: Application) : AndroidViewModel(application) {&#10;&#10;    private val db = FirebaseFirestore.getInstance()&#10;    private val auth = FirebaseAuth.getInstance()&#10;&#10;    private val _state = MutableLiveData(ProfiloState())&#10;    val state: LiveData&lt;ProfiloState&gt; get() = _state&#10;&#10;    init {&#10;        loadUserProfile()&#10;    }&#10;&#10;    private fun loadUserProfile() {&#10;        val currentUser = auth.currentUser&#10;        if (currentUser == null) {&#10;            updateState { &#10;                it.copy(&#10;                    isLoading = false,&#10;                    errorMessage = &quot;Utente non autenticato&quot;&#10;                ) &#10;            }&#10;            return&#10;        }&#10;&#10;        _state.value = _state.value?.copy(isLoading = true)&#10;        &#10;        viewModelScope.launch {&#10;            try {&#10;                val userDoc = db.collection(&quot;utenti&quot;).document(currentUser.uid).get().await()&#10;                val user = userDoc.toObject&lt;User&gt;()?.copy(uid = currentUser.uid)&#10;                &#10;                // Carica movimenti se presenti&#10;                val movimentiList = userDoc.get(&quot;movimenti&quot;) as? List&lt;Map&lt;String, Any&gt;&gt;&#10;                val movimenti = movimentiList?.mapNotNull { movimentoMap -&gt;&#10;                    try {&#10;                        Movimento(&#10;                            importo = (movimentoMap[&quot;importo&quot;] as? Number)?.toDouble() ?: 0.0,&#10;                            descrizione = movimentoMap[&quot;descrizione&quot;] as? String ?: &quot;&quot;,&#10;                            data = movimentoMap[&quot;data&quot;] as? com.google.firebase.Timestamp&#10;                        )&#10;                    } catch (e: Exception) {&#10;                        null&#10;                    }&#10;                } ?: emptyList()&#10;                &#10;                updateState { &#10;                    it.copy(&#10;                        user = user,&#10;                        movimenti = movimenti,&#10;                        isLoading = false,&#10;                        errorMessage = null&#10;                    ) &#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;ProfiloVM&quot;, &quot;Errore caricamento profilo utente&quot;, e)&#10;                updateState { &#10;                    it.copy(&#10;                        isLoading = false,&#10;                        errorMessage = &quot;Errore nel caricamento del profilo: ${e.message}&quot;&#10;                    ) &#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    fun updateProfile(displayName: String, email: String) {&#10;        val currentUser = auth.currentUser&#10;        if (currentUser == null) {&#10;            updateState { it.copy(errorMessage = &quot;Utente non autenticato&quot;) }&#10;            return&#10;        }&#10;&#10;        updateState { it.copy(isLoading = true) }&#10;&#10;        viewModelScope.launch {&#10;            try {&#10;                // Aggiorna in Firestore&#10;                db.collection(&quot;utenti&quot;)&#10;                    .document(currentUser.uid)&#10;                    .update(&#10;                        mapOf(&#10;                            &quot;displayName&quot; to displayName,&#10;                            &quot;email&quot; to email&#10;                        )&#10;                    )&#10;                    .await()&#10;&#10;                // Aggiorna Firebase Auth se necessario&#10;                if (currentUser.email != email) {&#10;                    currentUser.updateEmail(email).await()&#10;                }&#10;&#10;                updateState { &#10;                    it.copy(&#10;                        isLoading = false,&#10;                        successMessage = &quot;Profilo aggiornato con successo&quot;&#10;                    ) &#10;                }&#10;                &#10;                // Ricarica il profilo per mostrare i dati aggiornati&#10;                loadUserProfile()&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;ProfiloVM&quot;, &quot;Errore aggiornamento profilo&quot;, e)&#10;                updateState { &#10;                    it.copy(&#10;                        isLoading = false,&#10;                        errorMessage = &quot;Errore nell'aggiornamento del profilo: ${e.message}&quot;&#10;                    ) &#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    fun refreshProfile() {&#10;        loadUserProfile()&#10;    }&#10;&#10;    fun clearMessages() {&#10;        updateState { it.copy(errorMessage = null, successMessage = null) }&#10;    }&#10;&#10;    private fun updateState(updateAction: (ProfiloState) -&gt; ProfiloState) {&#10;        _state.value = updateAction(_state.value ?: ProfiloState())&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/circolapp/RicaricaViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/circolapp/RicaricaViewModel.kt" />
              <option name="updatedContent" value="package com.example.circolapp.viewmodel&#10;&#10;import android.app.Application&#10;import android.util.Log&#10;import androidx.lifecycle.AndroidViewModel&#10;import androidx.lifecycle.LiveData&#10;import androidx.lifecycle.MutableLiveData&#10;import androidx.lifecycle.viewModelScope&#10;import com.google.firebase.auth.FirebaseAuth&#10;import com.google.firebase.firestore.FirebaseFirestore&#10;import com.google.firebase.firestore.FieldValue&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.tasks.await&#10;&#10;data class RicaricaState(&#10;    val scannedCode: String = &quot;&quot;,&#10;    val username: String = &quot;&quot;,&#10;    val importo: String = &quot;&quot;,&#10;    val isLoading: Boolean = false,&#10;    val errorMessage: String? = null,&#10;    val successMessage: String? = null&#10;)&#10;&#10;class RicaricaViewModel(application: Application) : AndroidViewModel(application) {&#10;&#10;    private val db = FirebaseFirestore.getInstance()&#10;    private val auth = FirebaseAuth.getInstance()&#10;&#10;    private val _state = MutableLiveData(RicaricaState())&#10;    val state: LiveData&lt;RicaricaState&gt; get() = _state&#10;&#10;    fun setScannedCode(code: String) {&#10;        updateState { it.copy(scannedCode = code) }&#10;        loadUserByCode(code)&#10;    }&#10;&#10;    private fun loadUserByCode(uid: String) {&#10;        updateState { it.copy(isLoading = true) }&#10;        &#10;        viewModelScope.launch {&#10;            try {&#10;                val userDoc = db.collection(&quot;utenti&quot;).document(uid).get().await()&#10;                if (userDoc.exists()) {&#10;                    val displayName = userDoc.getString(&quot;displayName&quot;) ?: &quot;Utente sconosciuto&quot;&#10;                    updateState { &#10;                        it.copy(&#10;                            username = displayName,&#10;                            isLoading = false,&#10;                            errorMessage = null&#10;                        ) &#10;                    }&#10;                } else {&#10;                    updateState { &#10;                        it.copy(&#10;                            isLoading = false,&#10;                            errorMessage = &quot;Utente non trovato&quot;&#10;                        ) &#10;                    }&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;RicaricaVM&quot;, &quot;Errore caricamento utente&quot;, e)&#10;                updateState { &#10;                    it.copy(&#10;                        isLoading = false,&#10;                        errorMessage = &quot;Errore nel caricamento dell'utente: ${e.message}&quot;&#10;                    ) &#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    fun setImporto(importo: String) {&#10;        updateState { it.copy(importo = importo) }&#10;    }&#10;&#10;    fun confermaRicarica() {&#10;        val currentState = _state.value&#10;        val scannedCode = currentState?.scannedCode&#10;        val importoStr = currentState?.importo&#10;        &#10;        if (scannedCode.isNullOrEmpty() || importoStr.isNullOrEmpty()) {&#10;            updateState { it.copy(errorMessage = &quot;Dati mancanti per completare la ricarica&quot;) }&#10;            return&#10;        }&#10;&#10;        val importo = importoStr.toDoubleOrNull()&#10;        if (importo == null || importo &lt;= 0) {&#10;            updateState { it.copy(errorMessage = &quot;Importo non valido&quot;) }&#10;            return&#10;        }&#10;&#10;        updateState { it.copy(isLoading = true) }&#10;&#10;        viewModelScope.launch {&#10;            try {&#10;                // Aggiorna il saldo dell'utente&#10;                db.collection(&quot;utenti&quot;)&#10;                    .document(scannedCode)&#10;                    .update(&quot;saldo&quot;, FieldValue.increment(importo))&#10;                    .await()&#10;&#10;                // Registra la transazione nei movimenti&#10;                val movimento = hashMapOf(&#10;                    &quot;importo&quot; to importo,&#10;                    &quot;descrizione&quot; to &quot;Ricarica in cassa&quot;,&#10;                    &quot;data&quot; to FieldValue.serverTimestamp()&#10;                )&#10;&#10;                db.collection(&quot;utenti&quot;)&#10;                    .document(scannedCode)&#10;                    .update(&quot;movimenti&quot;, FieldValue.arrayUnion(movimento))&#10;                    .await()&#10;&#10;                updateState { &#10;                    it.copy(&#10;                        isLoading = false,&#10;                        successMessage = &quot;Ricarica completata con successo per €$importo&quot;,&#10;                        errorMessage = null&#10;                    ) &#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;RicaricaVM&quot;, &quot;Errore ricarica&quot;, e)&#10;                updateState { &#10;                    it.copy(&#10;                        isLoading = false,&#10;                        errorMessage = &quot;Errore nella ricarica: ${e.message}&quot;&#10;                    ) &#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    fun resetForm() {&#10;        _state.value = RicaricaState()&#10;    }&#10;&#10;    fun clearMessages() {&#10;        updateState { it.copy(errorMessage = null, successMessage = null) }&#10;    }&#10;&#10;    private fun updateState(updateAction: (RicaricaState) -&gt; RicaricaState) {&#10;        _state.value = updateAction(_state.value ?: RicaricaState())&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/circolapp/RiscuotiViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/circolapp/RiscuotiViewModel.kt" />
              <option name="updatedContent" value="package com.example.circolapp.viewmodel&#10;&#10;import android.app.Application&#10;import android.util.Log&#10;import androidx.lifecycle.AndroidViewModel&#10;import androidx.lifecycle.LiveData&#10;import androidx.lifecycle.MutableLiveData&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.circolapp.model.Product&#10;import com.google.firebase.auth.FirebaseAuth&#10;import com.google.firebase.firestore.FirebaseFirestore&#10;import com.google.firebase.firestore.FieldValue&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.tasks.await&#10;&#10;data class RiscuotiState(&#10;    val selectedUser: String = &quot;&quot;,&#10;    val username: String = &quot;&quot;,&#10;    val selectedProducts: MutableList&lt;Product&gt; = mutableListOf(),&#10;    val totale: Double = 0.0,&#10;    val isLoading: Boolean = false,&#10;    val errorMessage: String? = null,&#10;    val successMessage: String? = null&#10;)&#10;&#10;class RiscuotiViewModel(application: Application) : AndroidViewModel(application) {&#10;&#10;    private val db = FirebaseFirestore.getInstance()&#10;    private val auth = FirebaseAuth.getInstance()&#10;&#10;    private val _state = MutableLiveData(RiscuotiState())&#10;    val state: LiveData&lt;RiscuotiState&gt; get() = _state&#10;&#10;    fun setSelectedUser(userCode: String) {&#10;        updateState { it.copy(selectedUser = userCode) }&#10;        loadUserByCode(userCode)&#10;    }&#10;&#10;    private fun loadUserByCode(uid: String) {&#10;        updateState { it.copy(isLoading = true) }&#10;        &#10;        viewModelScope.launch {&#10;            try {&#10;                val userDoc = db.collection(&quot;utenti&quot;).document(uid).get().await()&#10;                if (userDoc.exists()) {&#10;                    val displayName = userDoc.getString(&quot;displayName&quot;) ?: &quot;Utente sconosciuto&quot;&#10;                    updateState { &#10;                        it.copy(&#10;                            username = displayName,&#10;                            isLoading = false,&#10;                            errorMessage = null&#10;                        ) &#10;                    }&#10;                } else {&#10;                    updateState { &#10;                        it.copy(&#10;                            isLoading = false,&#10;                            errorMessage = &quot;Utente non trovato&quot;&#10;                        ) &#10;                    }&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;RiscuotiVM&quot;, &quot;Errore caricamento utente&quot;, e)&#10;                updateState { &#10;                    it.copy(&#10;                        isLoading = false,&#10;                        errorMessage = &quot;Errore nel caricamento dell'utente: ${e.message}&quot;&#10;                    ) &#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    fun addProduct(productCode: String) {&#10;        viewModelScope.launch {&#10;            try {&#10;                val productDoc = db.collection(&quot;prodotti&quot;).document(productCode).get().await()&#10;                if (productDoc.exists()) {&#10;                    val product = productDoc.toObject(Product::class.java)?.copy(id = productCode)&#10;                    if (product != null) {&#10;                        val currentState = _state.value&#10;                        val updatedProducts = currentState?.selectedProducts?.toMutableList() ?: mutableListOf()&#10;                        updatedProducts.add(product)&#10;                        &#10;                        val newTotale = updatedProducts.sumOf { it.importo }&#10;                        &#10;                        updateState { &#10;                            it.copy(&#10;                                selectedProducts = updatedProducts,&#10;                                totale = newTotale,&#10;                                errorMessage = null&#10;                            ) &#10;                        }&#10;                    }&#10;                } else {&#10;                    updateState { &#10;                        it.copy(errorMessage = &quot;Prodotto non trovato con codice: $productCode&quot;) &#10;                    }&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;RiscuotiVM&quot;, &quot;Errore caricamento prodotto&quot;, e)&#10;                updateState { &#10;                    it.copy(errorMessage = &quot;Errore nel caricamento del prodotto: ${e.message}&quot;) &#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    fun removeProduct(product: Product) {&#10;        val currentState = _state.value&#10;        val updatedProducts = currentState?.selectedProducts?.toMutableList() ?: mutableListOf()&#10;        updatedProducts.remove(product)&#10;        &#10;        val newTotale = updatedProducts.sumOf { it.importo }&#10;        &#10;        updateState { &#10;            it.copy(&#10;                selectedProducts = updatedProducts,&#10;                totale = newTotale&#10;            ) &#10;        }&#10;    }&#10;&#10;    fun completaRiscossione() {&#10;        val currentState = _state.value&#10;        val selectedUser = currentState?.selectedUser&#10;        val totale = currentState?.totale&#10;        &#10;        if (selectedUser.isNullOrEmpty() || totale == null || totale &lt;= 0) {&#10;            updateState { it.copy(errorMessage = &quot;Dati mancanti per completare la riscossione&quot;) }&#10;            return&#10;        }&#10;&#10;        updateState { it.copy(isLoading = true) }&#10;&#10;        viewModelScope.launch {&#10;            try {&#10;                // Detraere il totale dal saldo dell'utente&#10;                db.collection(&quot;utenti&quot;)&#10;                    .document(selectedUser)&#10;                    .update(&quot;saldo&quot;, FieldValue.increment(-totale))&#10;                    .await()&#10;&#10;                // Registra la transazione nei movimenti&#10;                val movimento = hashMapOf(&#10;                    &quot;importo&quot; to -totale,&#10;                    &quot;descrizione&quot; to &quot;Pagamento in cassa&quot;,&#10;                    &quot;data&quot; to FieldValue.serverTimestamp()&#10;                )&#10;&#10;                db.collection(&quot;utenti&quot;)&#10;                    .document(selectedUser)&#10;                    .update(&quot;movimenti&quot;, FieldValue.arrayUnion(movimento))&#10;                    .await()&#10;&#10;                updateState { &#10;                    it.copy(&#10;                        isLoading = false,&#10;                        successMessage = &quot;Riscossione completata con successo per €$totale&quot;,&#10;                        errorMessage = null&#10;                    ) &#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;RiscuotiVM&quot;, &quot;Errore riscossione&quot;, e)&#10;                updateState { &#10;                    it.copy(&#10;                        isLoading = false,&#10;                        errorMessage = &quot;Errore nella riscossione: ${e.message}&quot;&#10;                    ) &#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    fun resetForm() {&#10;        _state.value = RiscuotiState()&#10;    }&#10;&#10;    fun clearMessages() {&#10;        updateState { it.copy(errorMessage = null, successMessage = null) }&#10;    }&#10;&#10;    private fun updateState(updateAction: (RiscuotiState) -&gt; RiscuotiState) {&#10;        _state.value = updateAction(_state.value ?: RiscuotiState())&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/circolapp/adapter/ProductListAdapter.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/circolapp/adapter/ProductListAdapter.kt" />
              <option name="updatedContent" value="package com.example.circolapp.adapter&#10;&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.TextView&#10;import androidx.recyclerview.widget.DiffUtil&#10;import androidx.recyclerview.widget.ListAdapter&#10;import androidx.recyclerview.widget.RecyclerView&#10;import com.example.circolapp.R&#10;import com.example.circolapp.model.Product&#10;import java.text.NumberFormat&#10;import java.util.*&#10;&#10;class ProductListAdapter(&#10;    private val onProductClick: (Product) -&gt; Unit = {}&#10;) : ListAdapter&lt;Product, ProductListAdapter.ProductViewHolder&gt;(ProductDiffCallback()) {&#10;&#10;    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ProductViewHolder {&#10;        val view = LayoutInflater.from(parent.context)&#10;            .inflate(R.layout.item_product_simple, parent, false)&#10;        return ProductViewHolder(view)&#10;    }&#10;&#10;    override fun onBindViewHolder(holder: ProductViewHolder, position: Int) {&#10;        holder.bind(getItem(position))&#10;    }&#10;&#10;    inner class ProductViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) {&#10;        private val textProductName: TextView = itemView.findViewById(R.id.textProductName)&#10;        private val textProductPrice: TextView = itemView.findViewById(R.id.textProductPrice)&#10;&#10;        fun bind(product: Product) {&#10;            textProductName.text = product.nome&#10;            textProductPrice.text = NumberFormat.getCurrencyInstance(Locale.ITALY)&#10;                .format(product.importo)&#10;&#10;            itemView.setOnClickListener {&#10;                onProductClick(product)&#10;            }&#10;        }&#10;    }&#10;&#10;    private class ProductDiffCallback : DiffUtil.ItemCallback&lt;Product&gt;() {&#10;        override fun areItemsTheSame(oldItem: Product, newItem: Product): Boolean {&#10;            return oldItem.id == newItem.id&#10;        }&#10;&#10;        override fun areContentsTheSame(oldItem: Product, newItem: Product): Boolean {&#10;            return oldItem == newItem&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/circolapp/data/repository/EventiRepositoryImpl.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/circolapp/data/repository/EventiRepositoryImpl.kt" />
              <option name="updatedContent" value="package com.example.circolapp.data.repository&#10;&#10;import com.example.circolapp.domain.model.Evento&#10;import com.google.firebase.firestore.FirebaseFirestore&#10;import kotlinx.coroutines.tasks.await&#10;&#10;interface EventiRepository {&#10;    suspend fun getAllEvents(): List&lt;Evento&gt;&#10;    suspend fun getEventById(id: String): Evento?&#10;    suspend fun addEvent(evento: Evento): Boolean&#10;    suspend fun updateEvent(evento: Evento): Boolean&#10;    suspend fun deleteEvent(id: String): Boolean&#10;    suspend fun addParticipant(eventId: String, userId: String): Boolean&#10;    suspend fun removeParticipant(eventId: String, userId: String): Boolean&#10;}&#10;&#10;class EventiRepositoryImpl : EventiRepository {&#10;    &#10;    private val firestore = FirebaseFirestore.getInstance()&#10;    &#10;    override suspend fun getAllEvents(): List&lt;Evento&gt; {&#10;        return try {&#10;            val documents = firestore.collection(&quot;eventi&quot;)&#10;                .get()&#10;                .await()&#10;            &#10;            documents.map { document -&gt;&#10;                Evento(&#10;                    id = document.id,&#10;                    titolo = document.getString(&quot;titolo&quot;) ?: &quot;&quot;,&#10;                    descrizione = document.getString(&quot;descrizione&quot;) ?: &quot;&quot;,&#10;                    data = document.getDate(&quot;data&quot;) ?: java.util.Date(),&#10;                    luogo = document.getString(&quot;luogo&quot;) ?: &quot;&quot;,&#10;                    maxPartecipanti = document.getLong(&quot;maxPartecipanti&quot;)?.toInt() ?: 0,&#10;                    partecipanti = document.get(&quot;partecipanti&quot;) as? List&lt;String&gt; ?: emptyList(),&#10;                    costo = document.getDouble(&quot;costo&quot;) ?: 0.0,&#10;                    imageUrl = document.getString(&quot;imageUrl&quot;)&#10;                )&#10;            }&#10;        } catch (e: Exception) {&#10;            emptyList()&#10;        }&#10;    }&#10;    &#10;    override suspend fun getEventById(id: String): Evento? {&#10;        return try {&#10;            val document = firestore.collection(&quot;eventi&quot;)&#10;                .document(id)&#10;                .get()&#10;                .await()&#10;            &#10;            if (document.exists()) {&#10;                Evento(&#10;                    id = document.id,&#10;                    titolo = document.getString(&quot;titolo&quot;) ?: &quot;&quot;,&#10;                    descrizione = document.getString(&quot;descrizione&quot;) ?: &quot;&quot;,&#10;                    data = document.getDate(&quot;data&quot;) ?: java.util.Date(),&#10;                    luogo = document.getString(&quot;luogo&quot;) ?: &quot;&quot;,&#10;                    maxPartecipanti = document.getLong(&quot;maxPartecipanti&quot;)?.toInt() ?: 0,&#10;                    partecipanti = document.get(&quot;partecipanti&quot;) as? List&lt;String&gt; ?: emptyList(),&#10;                    costo = document.getDouble(&quot;costo&quot;) ?: 0.0,&#10;                    imageUrl = document.getString(&quot;imageUrl&quot;)&#10;                )&#10;            } else null&#10;        } catch (e: Exception) {&#10;            null&#10;        }&#10;    }&#10;    &#10;    override suspend fun addEvent(evento: Evento): Boolean {&#10;        return try {&#10;            firestore.collection(&quot;eventi&quot;)&#10;                .document(evento.id)&#10;                .set(evento)&#10;                .await()&#10;            true&#10;        } catch (e: Exception) {&#10;            false&#10;        }&#10;    }&#10;    &#10;    override suspend fun updateEvent(evento: Evento): Boolean {&#10;        return try {&#10;            firestore.collection(&quot;eventi&quot;)&#10;                .document(evento.id)&#10;                .set(evento)&#10;                .await()&#10;            true&#10;        } catch (e: Exception) {&#10;            false&#10;        }&#10;    }&#10;    &#10;    override suspend fun deleteEvent(id: String): Boolean {&#10;        return try {&#10;            firestore.collection(&quot;eventi&quot;)&#10;                .document(id)&#10;                .delete()&#10;                .await()&#10;            true&#10;        } catch (e: Exception) {&#10;            false&#10;        }&#10;    }&#10;    &#10;    override suspend fun addParticipant(eventId: String, userId: String): Boolean {&#10;        return try {&#10;            val document = firestore.collection(&quot;eventi&quot;).document(eventId)&#10;            firestore.runTransaction { transaction -&gt;&#10;                val event = transaction.get(document)&#10;                val partecipanti = event.get(&quot;partecipanti&quot;) as? MutableList&lt;String&gt; ?: mutableListOf()&#10;                if (!partecipanti.contains(userId)) {&#10;                    partecipanti.add(userId)&#10;                    transaction.update(document, &quot;partecipanti&quot;, partecipanti)&#10;                }&#10;            }.await()&#10;            true&#10;        } catch (e: Exception) {&#10;            false&#10;        }&#10;    }&#10;    &#10;    override suspend fun removeParticipant(eventId: String, userId: String): Boolean {&#10;        return try {&#10;            val document = firestore.collection(&quot;eventi&quot;).document(eventId)&#10;            firestore.runTransaction { transaction -&gt;&#10;                val event = transaction.get(document)&#10;                val partecipanti = event.get(&quot;partecipanti&quot;) as? MutableList&lt;String&gt; ?: mutableListOf()&#10;                partecipanti.remove(userId)&#10;                transaction.update(document, &quot;partecipanti&quot;, partecipanti)&#10;            }.await()&#10;            true&#10;        } catch (e: Exception) {&#10;            false&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/circolapp/data/repository/ProductRepositoryImpl.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/circolapp/data/repository/ProductRepositoryImpl.kt" />
              <option name="updatedContent" value="package com.example.circolapp.data.repository&#10;&#10;import com.example.circolapp.domain.model.Product&#10;import com.google.firebase.firestore.FirebaseFirestore&#10;import kotlinx.coroutines.tasks.await&#10;&#10;interface ProductRepository {&#10;    suspend fun getAllProducts(): List&lt;Product&gt;&#10;    suspend fun getProductById(id: String): Product?&#10;    suspend fun addProduct(product: Product): Boolean&#10;    suspend fun updateProduct(product: Product): Boolean&#10;    suspend fun deleteProduct(id: String): Boolean&#10;}&#10;&#10;class ProductRepositoryImpl : ProductRepository {&#10;    &#10;    private val firestore = FirebaseFirestore.getInstance()&#10;    &#10;    override suspend fun getAllProducts(): List&lt;Product&gt; {&#10;        return try {&#10;            val documents = firestore.collection(&quot;products&quot;)&#10;                .get()&#10;                .await()&#10;            &#10;            documents.map { document -&gt;&#10;                Product(&#10;                    id = document.id,&#10;                    nome = document.getString(&quot;nome&quot;) ?: &quot;&quot;,&#10;                    descrizione = document.getString(&quot;descrizione&quot;) ?: &quot;&quot;,&#10;                    numeroPezzi = document.getLong(&quot;numeroPezzi&quot;)?.toInt() ?: 0,&#10;                    importo = document.getDouble(&quot;importo&quot;) ?: 0.0,&#10;                    imageUrl = document.getString(&quot;imageUrl&quot;),&#10;                    isOrdinabile = document.getBoolean(&quot;isOrdinabile&quot;) ?: true,&#10;                    categoria = document.getString(&quot;categoria&quot;) ?: &quot;&quot;&#10;                )&#10;            }&#10;        } catch (e: Exception) {&#10;            emptyList()&#10;        }&#10;    }&#10;    &#10;    override suspend fun getProductById(id: String): Product? {&#10;        return try {&#10;            val document = firestore.collection(&quot;products&quot;)&#10;                .document(id)&#10;                .get()&#10;                .await()&#10;            &#10;            if (document.exists()) {&#10;                Product(&#10;                    id = document.id,&#10;                    nome = document.getString(&quot;nome&quot;) ?: &quot;&quot;,&#10;                    descrizione = document.getString(&quot;descrizione&quot;) ?: &quot;&quot;,&#10;                    numeroPezzi = document.getLong(&quot;numeroPezzi&quot;)?.toInt() ?: 0,&#10;                    importo = document.getDouble(&quot;importo&quot;) ?: 0.0,&#10;                    imageUrl = document.getString(&quot;imageUrl&quot;),&#10;                    isOrdinabile = document.getBoolean(&quot;isOrdinabile&quot;) ?: true,&#10;                    categoria = document.getString(&quot;categoria&quot;) ?: &quot;&quot;&#10;                )&#10;            } else null&#10;        } catch (e: Exception) {&#10;            null&#10;        }&#10;    }&#10;    &#10;    override suspend fun addProduct(product: Product): Boolean {&#10;        return try {&#10;            firestore.collection(&quot;products&quot;)&#10;                .document(product.id)&#10;                .set(product)&#10;                .await()&#10;            true&#10;        } catch (e: Exception) {&#10;            false&#10;        }&#10;    }&#10;    &#10;    override suspend fun updateProduct(product: Product): Boolean {&#10;        return try {&#10;            firestore.collection(&quot;products&quot;)&#10;                .document(product.id)&#10;                .set(product)&#10;                .await()&#10;            true&#10;        } catch (e: Exception) {&#10;            false&#10;        }&#10;    }&#10;    &#10;    override suspend fun deleteProduct(id: String): Boolean {&#10;        return try {&#10;            firestore.collection(&quot;products&quot;)&#10;                .document(id)&#10;                .delete()&#10;                .await()&#10;            true&#10;        } catch (e: Exception) {&#10;            false&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/circolapp/data/repository/TesseraRepositoryImpl.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/circolapp/data/repository/TesseraRepositoryImpl.kt" />
              <option name="updatedContent" value="package com.example.circolapp.data.repository&#10;&#10;import com.example.circolapp.domain.model.RichiestaTessera&#10;import com.example.circolapp.domain.model.TipoRichiesta&#10;import com.example.circolapp.domain.model.StatoRichiesta&#10;import com.google.firebase.firestore.FirebaseFirestore&#10;import kotlinx.coroutines.tasks.await&#10;&#10;interface TesseraRepository {&#10;    suspend fun getAllRichieste(): List&lt;RichiestaTessera&gt;&#10;    suspend fun addRichiesta(richiesta: RichiestaTessera): Boolean&#10;    suspend fun updateRichiesta(richiesta: RichiestaTessera): Boolean&#10;    suspend fun deleteRichiesta(id: String): Boolean&#10;    suspend fun getRichiesteByUser(uidUtente: String): List&lt;RichiestaTessera&gt;&#10;}&#10;&#10;class TesseraRepositoryImpl : TesseraRepository {&#10;    &#10;    private val firestore = FirebaseFirestore.getInstance()&#10;    &#10;    override suspend fun getAllRichieste(): List&lt;RichiestaTessera&gt; {&#10;        return try {&#10;            val documents = firestore.collection(&quot;richieste_tessera&quot;)&#10;                .get()&#10;                .await()&#10;            &#10;            documents.map { document -&gt;&#10;                RichiestaTessera(&#10;                    id = document.id,&#10;                    uidUtente = document.getString(&quot;uidUtente&quot;) ?: &quot;&quot;,&#10;                    nomeUtente = document.getString(&quot;nomeUtente&quot;) ?: &quot;&quot;,&#10;                    emailUtente = document.getString(&quot;emailUtente&quot;) ?: &quot;&quot;,&#10;                    dataRichiesta = document.getDate(&quot;dataRichiesta&quot;) ?: java.util.Date(),&#10;                    tipo = TipoRichiesta.valueOf(document.getString(&quot;tipo&quot;) ?: &quot;NUOVA&quot;),&#10;                    stato = StatoRichiesta.valueOf(document.getString(&quot;stato&quot;) ?: &quot;IN_ATTESA&quot;),&#10;                    note = document.getString(&quot;note&quot;) ?: &quot;&quot;&#10;                )&#10;            }&#10;        } catch (e: Exception) {&#10;            emptyList()&#10;        }&#10;    }&#10;    &#10;    override suspend fun addRichiesta(richiesta: RichiestaTessera): Boolean {&#10;        return try {&#10;            firestore.collection(&quot;richieste_tessera&quot;)&#10;                .document(richiesta.id)&#10;                .set(richiesta)&#10;                .await()&#10;            true&#10;        } catch (e: Exception) {&#10;            false&#10;        }&#10;    }&#10;    &#10;    override suspend fun updateRichiesta(richiesta: RichiestaTessera): Boolean {&#10;        return try {&#10;            firestore.collection(&quot;richieste_tessera&quot;)&#10;                .document(richiesta.id)&#10;                .set(richiesta)&#10;                .await()&#10;            true&#10;        } catch (e: Exception) {&#10;            false&#10;        }&#10;    }&#10;    &#10;    override suspend fun deleteRichiesta(id: String): Boolean {&#10;        return try {&#10;            firestore.collection(&quot;richieste_tessera&quot;)&#10;                .document(id)&#10;                .delete()&#10;                .await()&#10;            true&#10;        } catch (e: Exception) {&#10;            false&#10;        }&#10;    }&#10;    &#10;    override suspend fun getRichiesteByUser(uidUtente: String): List&lt;RichiestaTessera&gt; {&#10;        return try {&#10;            val documents = firestore.collection(&quot;richieste_tessera&quot;)&#10;                .whereEqualTo(&quot;uidUtente&quot;, uidUtente)&#10;                .get()&#10;                .await()&#10;            &#10;            documents.map { document -&gt;&#10;                RichiestaTessera(&#10;                    id = document.id,&#10;                    uidUtente = document.getString(&quot;uidUtente&quot;) ?: &quot;&quot;,&#10;                    nomeUtente = document.getString(&quot;nomeUtente&quot;) ?: &quot;&quot;,&#10;                    emailUtente = document.getString(&quot;emailUtente&quot;) ?: &quot;&quot;,&#10;                    dataRichiesta = document.getDate(&quot;dataRichiesta&quot;) ?: java.util.Date(),&#10;                    tipo = TipoRichiesta.valueOf(document.getString(&quot;tipo&quot;) ?: &quot;NUOVA&quot;),&#10;                    stato = StatoRichiesta.valueOf(document.getString(&quot;stato&quot;) ?: &quot;IN_ATTESA&quot;),&#10;                    note = document.getString(&quot;note&quot;) ?: &quot;&quot;&#10;                )&#10;            }&#10;        } catch (e: Exception) {&#10;            emptyList()&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/circolapp/data/repository/UserRepositoryImpl.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/circolapp/data/repository/UserRepositoryImpl.kt" />
              <option name="updatedContent" value="package com.example.circolapp.data.repository&#10;&#10;import com.example.circolapp.domain.model.User&#10;import com.example.circolapp.domain.model.UserRole&#10;import com.google.firebase.auth.FirebaseAuth&#10;import com.google.firebase.firestore.FirebaseFirestore&#10;import kotlinx.coroutines.tasks.await&#10;import kotlinx.coroutines.flow.Flow&#10;import kotlinx.coroutines.flow.flow&#10;&#10;interface UserRepository {&#10;    suspend fun getCurrentUser(): User?&#10;    suspend fun getUserById(uid: String): User?&#10;    suspend fun updateUser(user: User): Boolean&#10;    suspend fun getAllUsers(): List&lt;User&gt;&#10;    fun getCurrentUserRole(): Flow&lt;UserRole&gt;&#10;}&#10;&#10;class UserRepositoryImpl : UserRepository {&#10;    &#10;    private val auth = FirebaseAuth.getInstance()&#10;    private val firestore = FirebaseFirestore.getInstance()&#10;    &#10;    override suspend fun getCurrentUser(): User? {&#10;        return try {&#10;            val currentUser = auth.currentUser ?: return null&#10;            val document = firestore.collection(&quot;utenti&quot;)&#10;                .document(currentUser.uid)&#10;                .get()&#10;                .await()&#10;            &#10;            if (document.exists()) {&#10;                User(&#10;                    uid = document.id,&#10;                    username = document.getString(&quot;username&quot;) ?: &quot;&quot;,&#10;                    nome = document.getString(&quot;displayName&quot;) ?: document.getString(&quot;nome&quot;) ?: &quot;&quot;,&#10;                    saldo = document.getDouble(&quot;saldo&quot;) ?: 0.0,&#10;                    photoUrl = document.getString(&quot;photoUrl&quot;),&#10;                    hasTessera = document.getBoolean(&quot;hasTessera&quot;) ?: false,&#10;                    numeroTessera = document.getString(&quot;numeroTessera&quot;),&#10;                    dataScadenzaTessera = document.getDate(&quot;dataScadenzaTessera&quot;),&#10;                    richiestaRinnovoInCorso = document.getBoolean(&quot;richiestaRinnovoInCorso&quot;) ?: false&#10;                )&#10;            } else null&#10;        } catch (e: Exception) {&#10;            null&#10;        }&#10;    }&#10;    &#10;    override suspend fun getUserById(uid: String): User? {&#10;        return try {&#10;            val document = firestore.collection(&quot;utenti&quot;)&#10;                .document(uid)&#10;                .get()&#10;                .await()&#10;            &#10;            if (document.exists()) {&#10;                User(&#10;                    uid = document.id,&#10;                    username = document.getString(&quot;username&quot;) ?: &quot;&quot;,&#10;                    nome = document.getString(&quot;displayName&quot;) ?: document.getString(&quot;nome&quot;) ?: &quot;&quot;,&#10;                    saldo = document.getDouble(&quot;saldo&quot;) ?: 0.0,&#10;                    photoUrl = document.getString(&quot;photoUrl&quot;),&#10;                    hasTessera = document.getBoolean(&quot;hasTessera&quot;) ?: false,&#10;                    numeroTessera = document.getString(&quot;numeroTessera&quot;),&#10;                    dataScadenzaTessera = document.getDate(&quot;dataScadenzaTessera&quot;),&#10;                    richiestaRinnovoInCorso = document.getBoolean(&quot;richiestaRinnovoInCorso&quot;) ?: false&#10;                )&#10;            } else null&#10;        } catch (e: Exception) {&#10;            null&#10;        }&#10;    }&#10;    &#10;    override suspend fun updateUser(user: User): Boolean {&#10;        return try {&#10;            firestore.collection(&quot;utenti&quot;)&#10;                .document(user.uid)&#10;                .set(user)&#10;                .await()&#10;            true&#10;        } catch (e: Exception) {&#10;            false&#10;        }&#10;    }&#10;    &#10;    override suspend fun getAllUsers(): List&lt;User&gt; {&#10;        return try {&#10;            val documents = firestore.collection(&quot;utenti&quot;)&#10;                .get()&#10;                .await()&#10;            &#10;            documents.map { document -&gt;&#10;                User(&#10;                    uid = document.id,&#10;                    username = document.getString(&quot;username&quot;) ?: &quot;&quot;,&#10;                    nome = document.getString(&quot;displayName&quot;) ?: document.getString(&quot;nome&quot;) ?: &quot;&quot;,&#10;                    saldo = document.getDouble(&quot;saldo&quot;) ?: 0.0,&#10;                    photoUrl = document.getString(&quot;photoUrl&quot;),&#10;                    hasTessera = document.getBoolean(&quot;hasTessera&quot;) ?: false,&#10;                    numeroTessera = document.getString(&quot;numeroTessera&quot;),&#10;                    dataScadenzaTessera = document.getDate(&quot;dataScadenzaTessera&quot;),&#10;                    richiestaRinnovoInCorso = document.getBoolean(&quot;richiestaRinnovoInCorso&quot;) ?: false&#10;                )&#10;            }&#10;        } catch (e: Exception) {&#10;            emptyList()&#10;        }&#10;    }&#10;    &#10;    override fun getCurrentUserRole(): Flow&lt;UserRole&gt; = flow {&#10;        try {&#10;            val currentUser = auth.currentUser&#10;            if (currentUser != null) {&#10;                val document = firestore.collection(&quot;utenti&quot;)&#10;                    .document(currentUser.uid)&#10;                    .get()&#10;                    .await()&#10;                &#10;                val ruolo = document.getString(&quot;ruolo&quot;) ?: &quot;USER&quot;&#10;                emit(UserRole.fromString(ruolo))&#10;            } else {&#10;                emit(UserRole.UNKNOWN)&#10;            }&#10;        } catch (e: Exception) {&#10;            emit(UserRole.UNKNOWN)&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/circolapp/domain/model/Chat.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/circolapp/domain/model/Chat.kt" />
              <option name="updatedContent" value="package com.example.circolapp.domain.model&#10;&#10;import java.util.Date&#10;&#10;data class Message(&#10;    val id: String = &quot;&quot;,&#10;    val chatId: String = &quot;&quot;,&#10;    val senderId: String = &quot;&quot;,&#10;    val senderName: String = &quot;&quot;,&#10;    val content: String = &quot;&quot;,&#10;    val timestamp: Date = Date(),&#10;    val messageType: MessageType = MessageType.TEXT&#10;)&#10;&#10;data class ChatConversation(&#10;    val id: String = &quot;&quot;,&#10;    val participants: List&lt;String&gt; = emptyList(),&#10;    val lastMessage: String = &quot;&quot;,&#10;    val lastMessageTime: Date = Date(),&#10;    val otherUserName: String = &quot;&quot;,&#10;    val otherUserPhotoUrl: String? = null&#10;)&#10;&#10;data class ChatItem(&#10;    val id: String = &quot;&quot;,&#10;    val name: String = &quot;&quot;,&#10;    val lastMessage: String = &quot;&quot;,&#10;    val timestamp: Date = Date(),&#10;    val photoUrl: String? = null&#10;)&#10;&#10;enum class MessageType {&#10;    TEXT, IMAGE, SYSTEM&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/circolapp/domain/model/Evento.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/circolapp/domain/model/Evento.kt" />
              <option name="updatedContent" value="package com.example.circolapp.domain.model&#10;&#10;import java.util.Date&#10;&#10;data class Evento(&#10;    val id: String = &quot;&quot;,&#10;    val titolo: String = &quot;&quot;,&#10;    val descrizione: String = &quot;&quot;,&#10;    val data: Date = Date(),&#10;    val luogo: String = &quot;&quot;,&#10;    val maxPartecipanti: Int = 0,&#10;    val partecipanti: List&lt;String&gt; = emptyList(),&#10;    val costo: Double = 0.0,&#10;    val imageUrl: String? = null&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/circolapp/domain/model/Feedback.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/circolapp/domain/model/Feedback.kt" />
              <option name="updatedContent" value="package com.example.circolapp.domain.model&#10;&#10;import java.util.Date&#10;&#10;data class Feedback(&#10;    val id: String = &quot;&quot;,&#10;    val uidUtente: String = &quot;&quot;,&#10;    val nomeUtente: String = &quot;&quot;,&#10;    val emailUtente: String = &quot;&quot;,&#10;    val titolo: String = &quot;&quot;,&#10;    val messaggio: String = &quot;&quot;,&#10;    val categoria: String = &quot;&quot;,&#10;    val letto: Boolean = false,&#10;    val dataCreazione: Date = Date()&#10;)&#10;&#10;data class Notifica(&#10;    val id: String = &quot;&quot;,&#10;    val uidUtente: String = &quot;&quot;,&#10;    val titolo: String = &quot;&quot;,&#10;    val messaggio: String = &quot;&quot;,&#10;    val letta: Boolean = false,&#10;    val dataCreazione: Date = Date()&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/circolapp/domain/model/Movimento.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/circolapp/domain/model/Movimento.kt" />
              <option name="updatedContent" value="package com.example.circolapp.domain.model&#10;&#10;import java.util.Date&#10;&#10;data class Movimento(&#10;    val importo: Double = 0.0,&#10;    val descrizione: String = &quot;&quot;,&#10;    val data: Date = Date()&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/circolapp/domain/model/Ordine.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/circolapp/domain/model/Ordine.kt" />
              <option name="updatedContent" value="package com.example.circolapp.domain.model&#10;&#10;import java.util.Date&#10;&#10;data class Ordine(&#10;    val id: String = &quot;&quot;,&#10;    val uidUtente: String = &quot;&quot;,&#10;    val nomeUtente: String = &quot;&quot;,&#10;    val prodotti: List&lt;OrdineItem&gt; = emptyList(),&#10;    val totale: Double = 0.0,&#10;    val dataOrdine: Date = Date(),&#10;    val stato: StatoOrdine = StatoOrdine.IN_ATTESA,&#10;    val note: String = &quot;&quot;&#10;)&#10;&#10;data class OrdineItem(&#10;    val prodottoId: String = &quot;&quot;,&#10;    val nomeProdotto: String = &quot;&quot;,&#10;    val quantita: Int = 1,&#10;    val prezzo: Double = 0.0&#10;)&#10;&#10;enum class StatoOrdine {&#10;    IN_ATTESA, COMPLETATO, CANCELLATO&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/circolapp/domain/model/Product.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/circolapp/domain/model/Product.kt" />
              <option name="updatedContent" value="package com.example.circolapp.domain.model&#10;&#10;import java.util.Date&#10;&#10;data class Product(&#10;    val id: String = &quot;&quot;,&#10;    val nome: String = &quot;&quot;,&#10;    val descrizione: String = &quot;&quot;,&#10;    val numeroPezzi: Int = 0,&#10;    val importo: Double = 0.0,&#10;    val imageUrl: String? = null,&#10;    val isOrdinabile: Boolean = true,&#10;    val categoria: String = &quot;&quot;&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/circolapp/domain/model/RichiestaTessera.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/circolapp/domain/model/RichiestaTessera.kt" />
              <option name="updatedContent" value="package com.example.circolapp.domain.model&#10;&#10;import java.util.Date&#10;&#10;data class RichiestaTessera(&#10;    val id: String = &quot;&quot;,&#10;    val uidUtente: String = &quot;&quot;,&#10;    val nomeUtente: String = &quot;&quot;,&#10;    val emailUtente: String = &quot;&quot;,&#10;    val dataRichiesta: Date = Date(),&#10;    val tipo: TipoRichiesta = TipoRichiesta.NUOVA,&#10;    val stato: StatoRichiesta = StatoRichiesta.IN_ATTESA,&#10;    val note: String = &quot;&quot;&#10;)&#10;&#10;enum class TipoRichiesta {&#10;    NUOVA, RINNOVO&#10;}&#10;&#10;enum class StatoRichiesta {&#10;    IN_ATTESA, APPROVATA, RIFIUTATA&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/circolapp/domain/model/User.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/circolapp/domain/model/User.kt" />
              <option name="updatedContent" value="package com.example.circolapp.domain.model&#10;&#10;import java.util.Date&#10;&#10;data class User(&#10;    val uid: String = &quot;&quot;,&#10;    val username: String = &quot;&quot;,&#10;    val nome: String = &quot;&quot;,&#10;    val saldo: Double = 0.0,&#10;    val movimenti: List&lt;Movimento&gt; = emptyList(),&#10;    val photoUrl: String? = null,&#10;    val hasTessera: Boolean = false,&#10;    val numeroTessera: String? = null,&#10;    val dataScadenzaTessera: Date? = null,&#10;    val richiestaRinnovoInCorso: Boolean = false&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/circolapp/domain/model/UserRole.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/circolapp/domain/model/UserRole.kt" />
              <option name="updatedContent" value="package com.example.circolapp.domain.model&#10;&#10;enum class UserRole(val displayName: String) {&#10;    USER(&quot;Utente&quot;),&#10;    ADMIN(&quot;Amministratore&quot;),&#10;    UNKNOWN(&quot;Sconosciuto&quot;);&#10;&#10;    companion object {&#10;        fun fromString(value: String): UserRole {&#10;            return when (value.uppercase()) {&#10;                &quot;ADMIN&quot; -&gt; ADMIN&#10;                &quot;USER&quot; -&gt; USER&#10;                else -&gt; UNKNOWN&#10;            }&#10;        }&#10;    }&#10;&#10;    fun getDisplayName(): String = displayName&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/circolapp/domain/usecase/CreaOrdineUseCase.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/circolapp/domain/usecase/CreaOrdineUseCase.kt" />
              <option name="updatedContent" value="package com.example.circolapp.domain.usecase&#10;&#10;import com.example.circolapp.data.repository.ProductRepository&#10;import com.example.circolapp.data.repository.UserRepository&#10;import com.example.circolapp.domain.model.Movimento&#10;import com.example.circolapp.domain.model.Ordine&#10;import com.example.circolapp.domain.model.OrdineItem&#10;import com.example.circolapp.domain.model.Product&#10;import com.example.circolapp.domain.model.StatoOrdine&#10;import com.google.firebase.firestore.FirebaseFirestore&#10;import kotlinx.coroutines.tasks.await&#10;import java.util.*&#10;&#10;class CreaOrdineUseCase(&#10;    private val userRepository: UserRepository,&#10;    private val productRepository: ProductRepository&#10;) {&#10;    &#10;    suspend fun execute(&#10;        uidUtente: String,&#10;        prodottoId: String,&#10;        quantita: Int = 1,&#10;        richieteAggiuntive: String = &quot;&quot;&#10;    ): Result&lt;String&gt; {&#10;        return try {&#10;            val user = userRepository.getUserById(uidUtente)&#10;                ?: return Result.failure(Exception(&quot;Utente non trovato&quot;))&#10;&#10;            val product = productRepository.getProductById(prodottoId)&#10;                ?: return Result.failure(Exception(&quot;Prodotto non trovato&quot;))&#10;&#10;            if (!product.isOrdinabile) {&#10;                return Result.failure(Exception(&quot;Questo prodotto non è ordinabile&quot;))&#10;            }&#10;&#10;            val totale = product.importo * quantita&#10;&#10;            // Verifica saldo sufficiente&#10;            if (user.saldo &lt; totale) {&#10;                return Result.failure(Exception(&quot;Saldo insufficiente. Necessari €${String.format(&quot;%.2f&quot;, totale)}&quot;))&#10;            }&#10;&#10;            // Crea l'ordine&#10;            val ordineItem = OrdineItem(&#10;                prodottoId = product.id,&#10;                nomeProdotto = product.nome,&#10;                quantita = quantita,&#10;                prezzo = product.importo&#10;            )&#10;&#10;            val ordine = Ordine(&#10;                id = UUID.randomUUID().toString(),&#10;                uidUtente = uidUtente,&#10;                nomeUtente = user.nome,&#10;                prodotti = listOf(ordineItem),&#10;                totale = totale,&#10;                note = richieteAggiuntive&#10;            )&#10;&#10;            // Scala il saldo e registra il movimento&#10;            val nuovoSaldo = user.saldo - totale&#10;            val movimento = Movimento(&#10;                importo = -totale,&#10;                descrizione = &quot;Pagamento ordine - ${product.nome}&quot;,&#10;                data = Date()&#10;            )&#10;&#10;            val userAggiornato = user.copy(&#10;                saldo = nuovoSaldo,&#10;                movimenti = user.movimenti + movimento&#10;            )&#10;&#10;            // Salva l'ordine su Firestore&#10;            val firestore = FirebaseFirestore.getInstance()&#10;            firestore.collection(&quot;ordinazioni&quot;).document(ordine.id).set(ordine).await()&#10;&#10;            // Aggiorna l'utente&#10;            val success = userRepository.updateUser(userAggiornato)&#10;            if (!success) {&#10;                return Result.failure(Exception(&quot;Errore nell'aggiornamento dell'utente&quot;))&#10;            }&#10;&#10;            Result.success(&quot;Ordine creato con successo!&quot;)&#10;&#10;        } catch (e: Exception) {&#10;            Result.failure(e)&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/circolapp/domain/usecase/RichiediTesseraUseCase.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/circolapp/domain/usecase/RichiediTesseraUseCase.kt" />
              <option name="updatedContent" value="package com.example.circolapp.domain.usecase&#10;&#10;import com.example.circolapp.data.repository.TesseraRepository&#10;import com.example.circolapp.data.repository.UserRepository&#10;import com.example.circolapp.domain.model.Movimento&#10;import com.example.circolapp.domain.model.RichiestaTessera&#10;import com.example.circolapp.domain.model.TipoRichiesta&#10;import com.example.circolapp.domain.model.User&#10;import java.util.*&#10;&#10;class RichiediTesseraUseCase(&#10;    private val userRepository: UserRepository,&#10;    private val tesseraRepository: TesseraRepository&#10;) {&#10;    companion object {&#10;        private const val QUOTA_TESSERA = 25.0&#10;    }&#10;&#10;    suspend fun execute(uidUtente: String, tipo: TipoRichiesta): Result&lt;String&gt; {&#10;        return try {&#10;            val user = userRepository.getUserById(uidUtente) &#10;                ?: return Result.failure(Exception(&quot;Utente non trovato&quot;))&#10;&#10;            // Verifica saldo sufficiente&#10;            if (user.saldo &lt; QUOTA_TESSERA) {&#10;                return Result.failure(Exception(&quot;Saldo insufficiente. Necessari €${QUOTA_TESSERA}&quot;))&#10;            }&#10;&#10;            // Verifica se ha già una richiesta in corso&#10;            if (user.richiestaRinnovoInCorso) {&#10;                return Result.failure(Exception(&quot;Hai già una richiesta in corso&quot;))&#10;            }&#10;&#10;            // Effettua il pagamento&#10;            val nuovoSaldo = user.saldo - QUOTA_TESSERA&#10;            val nuovoMovimento = Movimento(&#10;                importo = -QUOTA_TESSERA,&#10;                descrizione = &quot;Pagamento tessera socio&quot;,&#10;                data = Date()&#10;            )&#10;&#10;            val userAggiornato = user.copy(&#10;                saldo = nuovoSaldo,&#10;                movimenti = user.movimenti + nuovoMovimento,&#10;                richiestaRinnovoInCorso = true&#10;            )&#10;&#10;            // Aggiorna l'utente&#10;            val userUpdateSuccess = userRepository.updateUser(userAggiornato)&#10;            if (!userUpdateSuccess) {&#10;                return Result.failure(Exception(&quot;Errore nell'aggiornamento dell'utente&quot;))&#10;            }&#10;&#10;            // Crea la richiesta tessera&#10;            val richiesta = RichiestaTessera(&#10;                id = UUID.randomUUID().toString(),&#10;                uidUtente = uidUtente,&#10;                nomeUtente = user.nome,&#10;                emailUtente = &quot;&quot;, // Da completare se necessario&#10;                tipo = tipo&#10;            )&#10;&#10;            val richiestaSuccess = tesseraRepository.addRichiesta(richiesta)&#10;            if (!richiestaSuccess) {&#10;                return Result.failure(Exception(&quot;Errore nella creazione della richiesta&quot;))&#10;            }&#10;&#10;            Result.success(&quot;Pagamento effettuato e richiesta inviata con successo!&quot;)&#10;&#10;        } catch (e: Exception) {&#10;            Result.failure(e)&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/circolapp/model/Notifica.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/circolapp/model/Notifica.kt" />
              <option name="updatedContent" value="package com.example.circolapp.model&#10;&#10;import java.util.Date&#10;&#10;data class Notifica(&#10;    val id: String = &quot;&quot;,&#10;    val uidUtente: String = &quot;&quot;,&#10;    val titolo: String = &quot;&quot;,&#10;    val messaggio: String = &quot;&quot;,&#10;    val dataCreazione: Date? = null,&#10;    val letta: Boolean = false,&#10;    val tipo: String = &quot;INFO&quot; // &quot;INFO&quot;, &quot;WARNING&quot;, &quot;SUCCESS&quot;, &quot;ERROR&quot;&#10;) {&#10;    constructor() : this(&quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, null, false, &quot;INFO&quot;)&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/circolapp/model/TesseraRequest.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/circolapp/model/TesseraRequest.kt" />
              <option name="updatedContent" value="package com.example.circolapp.model&#10;&#10;import java.util.Date&#10;&#10;data class TesseraRequest(&#10;    val id: String = &quot;&quot;,&#10;    val uidUtente: String = &quot;&quot;,&#10;    val nomeUtente: String = &quot;&quot;,&#10;    val tipoRichiesta: String = &quot;&quot;, // &quot;NUOVA&quot; o &quot;RINNOVO&quot;&#10;    val dataRichiesta: Date? = null,&#10;    val stato: String = &quot;IN_ATTESA&quot;, // &quot;IN_ATTESA&quot;, &quot;APPROVATA&quot;, &quot;RIFIUTATA&quot;&#10;    val importoPagato: Double = 0.0,&#10;    val note: String? = null&#10;) {&#10;    constructor() : this(&quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, null, &quot;IN_ATTESA&quot;, 0.0, null)&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/circolapp/presentation/adapters/EventiAdapter.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/circolapp/presentation/adapters/EventiAdapter.kt" />
              <option name="updatedContent" value="package com.example.circolapp.presentation.adapters&#10;&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.Button&#10;import android.widget.TextView&#10;import androidx.recyclerview.widget.DiffUtil&#10;import androidx.recyclerview.widget.ListAdapter&#10;import androidx.recyclerview.widget.RecyclerView&#10;import com.example.circolapp.R&#10;import com.example.circolapp.domain.model.Evento&#10;import com.example.circolapp.domain.model.UserRole&#10;import java.text.SimpleDateFormat&#10;import java.util.*&#10;&#10;class EventiAdapter(&#10;    private val currentUserId: String,&#10;    private val userRole: UserRole,&#10;    private val onEventClick: (Evento) -&gt; Unit,&#10;    private val onParticipaClick: (Evento) -&gt; Unit&#10;) : ListAdapter&lt;Evento, EventiAdapter.EventoViewHolder&gt;(EventoDiffCallback()) {&#10;&#10;    private val dateFormatter = SimpleDateFormat(&quot;dd/MM/yyyy HH:mm&quot;, Locale.ITALY)&#10;&#10;    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): EventoViewHolder {&#10;        val view = LayoutInflater.from(parent.context)&#10;            .inflate(R.layout.item_evento, parent, false)&#10;        return EventoViewHolder(view)&#10;    }&#10;&#10;    override fun onBindViewHolder(holder: EventoViewHolder, position: Int) {&#10;        val evento = getItem(position)&#10;        holder.bind(evento)&#10;    }&#10;&#10;    inner class EventoViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) {&#10;        private val textTitolo: TextView = itemView.findViewById(R.id.text_evento_titolo)&#10;        private val textDescrizione: TextView = itemView.findViewById(R.id.text_evento_descrizione)&#10;        private val textData: TextView = itemView.findViewById(R.id.text_evento_data)&#10;        private val textLuogo: TextView = itemView.findViewById(R.id.text_evento_luogo)&#10;        private val textPartecipanti: TextView = itemView.findViewById(R.id.text_evento_partecipanti)&#10;        private val buttonPartecipa: Button = itemView.findViewById(R.id.button_partecipa)&#10;&#10;        fun bind(evento: Evento) {&#10;            textTitolo.text = evento.titolo&#10;            textDescrizione.text = evento.descrizione&#10;            textData.text = dateFormatter.format(evento.data)&#10;            textLuogo.text = evento.luogo&#10;            textPartecipanti.text = &quot;${evento.partecipanti.size}/${evento.maxPartecipanti} partecipanti&quot;&#10;&#10;            // Gestione del pulsante partecipa&#10;            when {&#10;                userRole == UserRole.ADMIN -&gt; {&#10;                    // Gli admin non vedono il pulsante partecipa&#10;                    buttonPartecipa.visibility = View.GONE&#10;                }&#10;                evento.partecipanti.contains(currentUserId) -&gt; {&#10;                    buttonPartecipa.text = &quot;Rimuovi Partecipazione&quot;&#10;                    buttonPartecipa.visibility = View.VISIBLE&#10;                    buttonPartecipa.setOnClickListener { onParticipaClick(evento) }&#10;                }&#10;                evento.partecipanti.size &lt; evento.maxPartecipanti -&gt; {&#10;                    buttonPartecipa.text = &quot;Partecipa&quot;&#10;                    buttonPartecipa.visibility = View.VISIBLE&#10;                    buttonPartecipa.setOnClickListener { onParticipaClick(evento) }&#10;                }&#10;                else -&gt; {&#10;                    buttonPartecipa.text = &quot;Completo&quot;&#10;                    buttonPartecipa.visibility = View.VISIBLE&#10;                    buttonPartecipa.isEnabled = false&#10;                }&#10;            }&#10;&#10;            itemView.setOnClickListener { onEventClick(evento) }&#10;        }&#10;    }&#10;&#10;    class EventoDiffCallback : DiffUtil.ItemCallback&lt;Evento&gt;() {&#10;        override fun areItemsTheSame(oldItem: Evento, newItem: Evento): Boolean {&#10;            return oldItem.id == newItem.id&#10;        }&#10;&#10;        override fun areContentsTheSame(oldItem: Evento, newItem: Evento): Boolean {&#10;            return oldItem == newItem&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/circolapp/presentation/adapters/ProductAdapter.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/circolapp/presentation/adapters/ProductAdapter.kt" />
              <option name="updatedContent" value="package com.example.circolapp.presentation.adapters&#10;&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.Button&#10;import android.widget.TextView&#10;import androidx.recyclerview.widget.DiffUtil&#10;import androidx.recyclerview.widget.ListAdapter&#10;import androidx.recyclerview.widget.RecyclerView&#10;import com.example.circolapp.R&#10;import com.example.circolapp.domain.model.Product&#10;import com.example.circolapp.domain.model.UserRole&#10;import java.text.NumberFormat&#10;import java.util.*&#10;&#10;class ProductAdapter(&#10;    private val userRole: UserRole,&#10;    private val onProductClick: (Product) -&gt; Unit,&#10;    private val onEditClick: ((Product) -&gt; Unit)? = null&#10;) : ListAdapter&lt;Product, ProductAdapter.ProductViewHolder&gt;(ProductDiffCallback()) {&#10;&#10;    private val currencyFormatter = NumberFormat.getCurrencyInstance(Locale.ITALY)&#10;&#10;    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ProductViewHolder {&#10;        val view = LayoutInflater.from(parent.context)&#10;            .inflate(R.layout.item_product, parent, false)&#10;        return ProductViewHolder(view)&#10;    }&#10;&#10;    override fun onBindViewHolder(holder: ProductViewHolder, position: Int) {&#10;        val product = getItem(position)&#10;        holder.bind(product)&#10;    }&#10;&#10;    inner class ProductViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) {&#10;        private val textNome: TextView = itemView.findViewById(R.id.text_product_name)&#10;        private val textDescrizione: TextView = itemView.findViewById(R.id.text_product_description)&#10;        private val textImporto: TextView = itemView.findViewById(R.id.text_product_price)&#10;        private val textPezzi: TextView = itemView.findViewById(R.id.text_product_pieces)&#10;        private val buttonEdit: Button? = itemView.findViewById(R.id.button_edit_product)&#10;&#10;        fun bind(product: Product) {&#10;            textNome.text = product.nome&#10;            textDescrizione.text = product.descrizione&#10;            textImporto.text = currencyFormatter.format(product.importo)&#10;            textPezzi.text = &quot;Pezzi: ${product.numeroPezzi}&quot;&#10;&#10;            // Mostra il pulsante edit solo per gli admin&#10;            if (userRole == UserRole.ADMIN &amp;&amp; onEditClick != null) {&#10;                buttonEdit?.visibility = View.VISIBLE&#10;                buttonEdit?.setOnClickListener { onEditClick.invoke(product) }&#10;            } else {&#10;                buttonEdit?.visibility = View.GONE&#10;            }&#10;&#10;            itemView.setOnClickListener { onProductClick(product) }&#10;        }&#10;    }&#10;&#10;    class ProductDiffCallback : DiffUtil.ItemCallback&lt;Product&gt;() {&#10;        override fun areItemsTheSame(oldItem: Product, newItem: Product): Boolean {&#10;            return oldItem.id == newItem.id&#10;        }&#10;&#10;        override fun areContentsTheSame(oldItem: Product, newItem: Product): Boolean {&#10;            return oldItem == newItem&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/circolapp/presentation/fragments/EventiFragment.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/circolapp/presentation/fragments/EventiFragment.kt" />
              <option name="updatedContent" value="package com.example.circolapp.presentation.fragments&#10;&#10;import android.os.Bundle&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.Toast&#10;import androidx.fragment.app.Fragment&#10;import androidx.fragment.app.viewModels&#10;import androidx.lifecycle.lifecycleScope&#10;import androidx.navigation.fragment.findNavController&#10;import androidx.recyclerview.widget.LinearLayoutManager&#10;import androidx.recyclerview.widget.RecyclerView&#10;import com.example.circolapp.R&#10;import com.example.circolapp.data.repository.EventiRepositoryImpl&#10;import com.example.circolapp.data.repository.UserRepositoryImpl&#10;import com.example.circolapp.domain.model.Evento&#10;import com.example.circolapp.domain.model.UserRole&#10;import com.example.circolapp.presentation.adapters.EventiAdapter&#10;import com.example.circolapp.presentation.viewmodel.EventiViewModel&#10;import com.example.circolapp.presentation.viewmodel.EventiViewModelFactory&#10;import com.google.android.material.floatingactionbutton.FloatingActionButton&#10;import kotlinx.coroutines.launch&#10;&#10;class EventiFragment : Fragment() {&#10;&#10;    private lateinit var recyclerView: RecyclerView&#10;    private lateinit var eventiAdapter: EventiAdapter&#10;    private lateinit var fabAddEvent: FloatingActionButton&#10;&#10;    private val viewModel: EventiViewModel by viewModels {&#10;        EventiViewModelFactory(&#10;            EventiRepositoryImpl(),&#10;            UserRepositoryImpl()&#10;        )&#10;    }&#10;&#10;    override fun onCreateView(&#10;        inflater: LayoutInflater, container: ViewGroup?,&#10;        savedInstanceState: Bundle?&#10;    ): View? {&#10;        val view = inflater.inflate(R.layout.fragment_eventi, container, false)&#10;&#10;        initializeViews(view)&#10;        setupRecyclerView()&#10;        setupClickListeners()&#10;        observeViewModel()&#10;&#10;        return view&#10;    }&#10;&#10;    private fun initializeViews(view: View) {&#10;        recyclerView = view.findViewById(R.id.recyclerViewEventi)&#10;        fabAddEvent = view.findViewById(R.id.fab_add_event)&#10;    }&#10;&#10;    private fun setupRecyclerView() {&#10;        recyclerView.layoutManager = LinearLayoutManager(requireContext())&#10;    }&#10;&#10;    private fun setupClickListeners() {&#10;        fabAddEvent.setOnClickListener {&#10;            navigateToAddEvent()&#10;        }&#10;    }&#10;&#10;    private fun observeViewModel() {&#10;        viewLifecycleOwner.lifecycleScope.launch {&#10;            viewModel.uiState.collect { state -&gt;&#10;                updateUI(state)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun updateUI(state: com.example.circolapp.presentation.viewmodel.EventiUiState) {&#10;        if (state.isLoading) {&#10;            // Mostra loading se necessario&#10;            return&#10;        }&#10;&#10;        state.errorMessage?.let { message -&gt;&#10;            Toast.makeText(context, message, Toast.LENGTH_SHORT).show()&#10;            viewModel.clearMessages()&#10;        }&#10;&#10;        state.successMessage?.let { message -&gt;&#10;            Toast.makeText(context, message, Toast.LENGTH_SHORT).show()&#10;            viewModel.clearMessages()&#10;        }&#10;&#10;        // Inizializza l'adapter se non esiste ancora&#10;        if (!::eventiAdapter.isInitialized) {&#10;            eventiAdapter = EventiAdapter(&#10;                currentUserId = state.currentUserId,&#10;                userRole = state.currentUserRole,&#10;                onEventClick = { evento -&gt; handleEventClick(evento, state.currentUserRole) },&#10;                onParticipaClick = { evento -&gt; handlePartecipazione(evento) }&#10;            )&#10;            recyclerView.adapter = eventiAdapter&#10;        }&#10;&#10;        // Aggiorna la lista degli eventi&#10;        eventiAdapter.submitList(state.eventi)&#10;&#10;        // Mostra/nascondi il FAB per aggiungere eventi (solo admin)&#10;        fabAddEvent.visibility = if (state.currentUserRole == UserRole.ADMIN) {&#10;            View.VISIBLE&#10;        } else {&#10;            View.GONE&#10;        }&#10;    }&#10;&#10;    private fun handleEventClick(evento: Evento, userRole: UserRole) {&#10;        try {&#10;            val action = EventiFragmentDirections&#10;                .actionEventiFragmentToInfoEventoFragment(evento, userRole)&#10;            findNavController().navigate(action)&#10;        } catch (e: Exception) {&#10;            Toast.makeText(context, &quot;Errore nella navigazione: ${e.message}&quot;, Toast.LENGTH_SHORT).show()&#10;        }&#10;    }&#10;&#10;    private fun handlePartecipazione(evento: Evento) {&#10;        if (viewModel.isUserParticipating(evento)) {&#10;            viewModel.rimuoviPartecipazione(evento.id)&#10;        } else if (viewModel.canUserParticipate(evento)) {&#10;            viewModel.participaEvento(evento.id)&#10;        } else {&#10;            Toast.makeText(context, &quot;Evento al completo!&quot;, Toast.LENGTH_SHORT).show()&#10;        }&#10;    }&#10;&#10;    private fun navigateToAddEvent() {&#10;        try {&#10;            findNavController().navigate(R.id.action_eventiFragment_to_addEventoFragment)&#10;        } catch (e: Exception) {&#10;            Toast.makeText(context, &quot;Errore nella navigazione: ${e.message}&quot;, Toast.LENGTH_SHORT).show()&#10;        }&#10;    }&#10;&#10;    override fun onResume() {&#10;        super.onResume()&#10;        // Ricarica gli eventi quando si torna al fragment&#10;        viewModel.refreshEvents()&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/circolapp/presentation/fragments/GestisciTessereFragment.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/circolapp/presentation/fragments/GestisciTessereFragment.kt" />
              <option name="updatedContent" value="package com.example.circolapp.presentation.fragments&#10;&#10;import android.os.Bundle&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.Toast&#10;import androidx.fragment.app.Fragment&#10;import androidx.fragment.app.viewModels&#10;import androidx.lifecycle.lifecycleScope&#10;import androidx.recyclerview.widget.LinearLayoutManager&#10;import androidx.recyclerview.widget.RecyclerView&#10;import com.example.circolapp.R&#10;import com.example.circolapp.data.repository.TesseraRepositoryImpl&#10;import com.example.circolapp.data.repository.UserRepositoryImpl&#10;import com.example.circolapp.domain.model.User&#10;import com.example.circolapp.presentation.adapters.GestisciTessereAdapter&#10;import com.example.circolapp.presentation.dialogs.GestisciTesseraDialog&#10;import com.example.circolapp.presentation.viewmodel.GestisciTessereViewModel&#10;import com.example.circolapp.presentation.viewmodel.GestisciTessereViewModelFactory&#10;import kotlinx.coroutines.launch&#10;&#10;class GestisciTessereFragment : Fragment() {&#10;&#10;    private lateinit var recyclerView: RecyclerView&#10;    private lateinit var adapter: GestisciTessereAdapter&#10;&#10;    private val viewModel: GestisciTessereViewModel by viewModels {&#10;        GestisciTessereViewModelFactory(&#10;            UserRepositoryImpl(),&#10;            TesseraRepositoryImpl()&#10;        )&#10;    }&#10;&#10;    override fun onCreateView(&#10;        inflater: LayoutInflater, container: ViewGroup?,&#10;        savedInstanceState: Bundle?&#10;    ): View? {&#10;        val view = inflater.inflate(R.layout.fragment_gestisci_tessere, container, false)&#10;&#10;        initializeViews(view)&#10;        setupRecyclerView()&#10;        observeViewModel()&#10;&#10;        return view&#10;    }&#10;&#10;    private fun initializeViews(view: View) {&#10;        recyclerView = view.findViewById(R.id.recyclerViewRichieste)&#10;    }&#10;&#10;    private fun setupRecyclerView() {&#10;        adapter = GestisciTessereAdapter { utente, azione -&gt;&#10;            when (azione) {&#10;                &quot;gestisci&quot; -&gt; mostraDettagliUtente(utente)&#10;            }&#10;        }&#10;        recyclerView.layoutManager = LinearLayoutManager(requireContext())&#10;        recyclerView.adapter = adapter&#10;    }&#10;&#10;    private fun observeViewModel() {&#10;        viewLifecycleOwner.lifecycleScope.launch {&#10;            viewModel.uiState.collect { state -&gt;&#10;                updateUI(state)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun updateUI(state: com.example.circolapp.presentation.viewmodel.GestisciTessereUiState) {&#10;        if (state.isLoading) {&#10;            // Mostra loading se necessario&#10;            return&#10;        }&#10;&#10;        state.errorMessage?.let { message -&gt;&#10;            Toast.makeText(context, message, Toast.LENGTH_SHORT).show()&#10;            viewModel.clearMessages()&#10;        }&#10;&#10;        state.successMessage?.let { message -&gt;&#10;            Toast.makeText(context, message, Toast.LENGTH_SHORT).show()&#10;            viewModel.clearMessages()&#10;        }&#10;&#10;        // Aggiorna la lista degli utenti&#10;        adapter.submitList(state.utenti)&#10;    }&#10;&#10;    private fun mostraDettagliUtente(utente: User) {&#10;        val dialog = GestisciTesseraDialog(&#10;            utente = utente,&#10;            onApprova = { viewModel.approvaRichiesta(utente) },&#10;            onRifiuta = { viewModel.rifiutaRichiesta(utente) },&#10;            onAssegna = { viewModel.assegnaTessera(utente) },&#10;            onRinnova = { viewModel.rinnovaTessera(utente) },&#10;            onRevoca = { viewModel.revocaTessera(utente) }&#10;        )&#10;        dialog.show(parentFragmentManager, &quot;GestisciTesseraDialog&quot;)&#10;    }&#10;&#10;    override fun onResume() {&#10;        super.onResume()&#10;        // Ricarica i dati quando si torna al fragment&#10;        viewModel.refreshData()&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/circolapp/presentation/fragments/ProductCatalogFragment.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/circolapp/presentation/fragments/ProductCatalogFragment.kt" />
              <option name="updatedContent" value="package com.example.circolapp.presentation.fragments&#10;&#10;import android.os.Bundle&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.Toast&#10;import androidx.fragment.app.Fragment&#10;import androidx.fragment.app.viewModels&#10;import androidx.lifecycle.lifecycleScope&#10;import androidx.navigation.fragment.findNavController&#10;import androidx.recyclerview.widget.LinearLayoutManager&#10;import androidx.recyclerview.widget.RecyclerView&#10;import com.example.circolapp.R&#10;import com.example.circolapp.data.repository.ProductRepositoryImpl&#10;import com.example.circolapp.data.repository.UserRepositoryImpl&#10;import com.example.circolapp.domain.model.Product&#10;import com.example.circolapp.domain.model.UserRole&#10;import com.example.circolapp.presentation.adapters.ProductAdapter&#10;import com.example.circolapp.presentation.viewmodel.ProductCatalogViewModel&#10;import com.example.circolapp.presentation.viewmodel.ProductCatalogViewModelFactory&#10;import kotlinx.coroutines.launch&#10;&#10;class ProductCatalogFragment : Fragment() {&#10;&#10;    private lateinit var recyclerView: RecyclerView&#10;    private lateinit var productAdapter: ProductAdapter&#10;&#10;    private val viewModel: ProductCatalogViewModel by viewModels {&#10;        ProductCatalogViewModelFactory(&#10;            ProductRepositoryImpl(),&#10;            UserRepositoryImpl()&#10;        )&#10;    }&#10;&#10;    override fun onCreateView(&#10;        inflater: LayoutInflater, container: ViewGroup?,&#10;        savedInstanceState: Bundle?&#10;    ): View? {&#10;        val view = inflater.inflate(R.layout.fragment_product_catalog, container, false)&#10;&#10;        initializeViews(view)&#10;        observeViewModel()&#10;&#10;        return view&#10;    }&#10;&#10;    private fun initializeViews(view: View) {&#10;        recyclerView = view.findViewById(R.id.recyclerViewProducts)&#10;        recyclerView.layoutManager = LinearLayoutManager(requireContext())&#10;    }&#10;&#10;    private fun observeViewModel() {&#10;        viewLifecycleOwner.lifecycleScope.launch {&#10;            viewModel.uiState.collect { state -&gt;&#10;                updateUI(state)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun updateUI(state: com.example.circolapp.presentation.viewmodel.ProductCatalogUiState) {&#10;        if (state.isLoading) {&#10;            // Mostra loading se necessario&#10;            return&#10;        }&#10;&#10;        state.errorMessage?.let { message -&gt;&#10;            Toast.makeText(context, message, Toast.LENGTH_SHORT).show()&#10;            viewModel.clearError()&#10;        }&#10;&#10;        // Inizializza l'adapter se non esiste ancora&#10;        if (!::productAdapter.isInitialized) {&#10;            productAdapter = ProductAdapter(&#10;                userRole = state.currentUserRole,&#10;                onProductClick = { product -&gt; handleProductClick(product) },&#10;                onEditClick = if (state.currentUserRole == UserRole.ADMIN) {&#10;                    { product -&gt; handleEditProduct(product) }&#10;                } else null&#10;            )&#10;            recyclerView.adapter = productAdapter&#10;        }&#10;&#10;        // Aggiorna la lista dei prodotti filtrati&#10;        val filteredProducts = viewModel.getFilteredProducts()&#10;        productAdapter.submitList(filteredProducts)&#10;    }&#10;&#10;    private fun handleProductClick(product: Product) {&#10;        try {&#10;            // Naviga al dettaglio del prodotto&#10;            val action = ProductCatalogFragmentDirections&#10;                .actionProductCatalogFragmentToDettaglioProdottoFragment(product)&#10;            findNavController().navigate(action)&#10;        } catch (e: Exception) {&#10;            Toast.makeText(context, &quot;Errore nella navigazione: ${e.message}&quot;, Toast.LENGTH_SHORT).show()&#10;        }&#10;    }&#10;&#10;    private fun handleEditProduct(product: Product) {&#10;        try {&#10;            // Naviga alla modifica del prodotto (solo per admin)&#10;            val action = ProductCatalogFragmentDirections&#10;                .actionProductCatalogFragmentToAddEditProductFragment(product.id)&#10;            findNavController().navigate(action)&#10;        } catch (e: Exception) {&#10;            Toast.makeText(context, &quot;Errore nella navigazione: ${e.message}&quot;, Toast.LENGTH_SHORT).show()&#10;        }&#10;    }&#10;&#10;    override fun onResume() {&#10;        super.onResume()&#10;        // Ricarica i prodotti quando si torna al fragment&#10;        viewModel.refreshProducts()&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/circolapp/presentation/fragments/ProfiloFragment.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/circolapp/presentation/fragments/ProfiloFragment.kt" />
              <option name="originalContent" value="package com.example.circolapp.presentation.fragments&#10;&#10;import android.content.Intent&#10;import android.os.Bundle&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.Button&#10;import android.widget.TextView&#10;import android.widget.Toast&#10;import androidx.fragment.app.Fragment&#10;import androidx.fragment.app.viewModels&#10;import androidx.lifecycle.lifecycleScope&#10;import androidx.navigation.fragment.findNavController&#10;import com.example.circolapp.LoginActivity&#10;import com.example.circolapp.R&#10;import com.example.circolapp.data.repository.UserRepositoryImpl&#10;import com.example.circolapp.domain.model.TipoRichiesta&#10;import com.example.circolapp.domain.model.UserRole&#10;import com.example.circolapp.domain.usecase.RichiediTesseraUseCase&#10;import com.example.circolapp.presentation.viewmodel.ProfiloViewModel&#10;import com.example.circolapp.presentation.viewmodel.ProfiloViewModelFactory&#10;import com.firebase.ui.auth.AuthUI&#10;import kotlinx.coroutines.launch&#10;import java.text.NumberFormat&#10;import java.text.SimpleDateFormat&#10;import java.util.*&#10;&#10;class ProfiloFragment : Fragment() {&#10;&#10;    private lateinit var textNome: TextView&#10;    private lateinit var textEmail: TextView&#10;    private lateinit var textTelefono: TextView&#10;    private lateinit var textSaldo: TextView&#10;    private lateinit var textRuolo: TextView&#10;    private lateinit var textTesseraStatus: TextView&#10;    private lateinit var textNumeroTessera: TextView&#10;    private lateinit var textScadenzaTessera: TextView&#10;    private lateinit var buttonTessera: Button&#10;    private lateinit var buttonGestisciTessere: Button&#10;    private lateinit var buttonFeedback: Button&#10;&#10;    private val currencyFormatter = NumberFormat.getCurrencyInstance(Locale.ITALY)&#10;    private val dateFormatter = SimpleDateFormat(&quot;dd/MM/yyyy&quot;, Locale.ITALY)&#10;&#10;    private val viewModel: ProfiloViewModel by viewModels {&#10;        ProfiloViewModelFactory(UserRepositoryImpl())&#10;    }&#10;&#10;    override fun onCreateView(&#10;        inflater: LayoutInflater, container: ViewGroup?,&#10;        savedInstanceState: Bundle?&#10;    ): View? {&#10;        val view = inflater.inflate(R.layout.fragment_profilo, container, false)&#10;&#10;        initializeViews(view)&#10;        setupClickListeners()&#10;        observeViewModel()&#10;&#10;        return view&#10;    }&#10;&#10;    private fun initializeViews(view: View) {&#10;        textNome = view.findViewById(R.id.text_nome)&#10;        textEmail = view.findViewById(R.id.text_email)&#10;        textTelefono = view.findViewById(R.id.text_telefono)&#10;        textSaldo = view.findViewById(R.id.text_saldo)&#10;        textRuolo = view.findViewById(R.id.text_ruolo)&#10;        textTesseraStatus = view.findViewById(R.id.text_tessera_status)&#10;        textNumeroTessera = view.findViewById(R.id.text_numero_tessera)&#10;        textScadenzaTessera = view.findViewById(R.id.text_scadenza_tessera)&#10;        buttonTessera = view.findViewById(R.id.buttonTessera)&#10;        buttonGestisciTessere = view.findViewById(R.id.buttonGestisciTessere)&#10;        buttonFeedback = view.findViewById(R.id.buttonFeedback)&#10;    }&#10;&#10;    private fun setupClickListeners() {&#10;        view?.findViewById&lt;Button&gt;(R.id.buttonLogout)?.setOnClickListener {&#10;            logout()&#10;        }&#10;&#10;        buttonFeedback.setOnClickListener {&#10;            handleFeedbackClick()&#10;        }&#10;&#10;        buttonTessera.setOnClickListener {&#10;            handleTesseraRequest()&#10;        }&#10;&#10;        buttonGestisciTessere.setOnClickListener {&#10;            navigateToGestisciTessere()&#10;        }&#10;    }&#10;&#10;    private fun observeViewModel() {&#10;        viewLifecycleOwner.lifecycleScope.launch {&#10;            viewModel.uiState.collect { state -&gt;&#10;                updateUI(state)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun updateUI(state: com.example.circolapp.presentation.viewmodel.ProfiloUiState) {&#10;        if (state.isLoading) {&#10;            // Mostra loading se necessario&#10;            return&#10;        }&#10;&#10;        state.errorMessage?.let { message -&gt;&#10;            Toast.makeText(context, message, Toast.LENGTH_SHORT).show()&#10;            viewModel.clearError()&#10;        }&#10;&#10;        state.user?.let { user -&gt;&#10;            textNome.text = user.nome.ifEmpty { &quot;Nome non disponibile&quot; }&#10;            textEmail.text = &quot;Email non disponibile&quot; // Da implementare se necessario&#10;            textTelefono.text = &quot;Telefono: Non disponibile&quot; // Da implementare se necessario&#10;            textSaldo.text = &quot;Saldo: ${currencyFormatter.format(user.saldo)}&quot;&#10;&#10;            updateTesseraInfo(user)&#10;        }&#10;&#10;        textRuolo.text = &quot;Ruolo: ${state.userRole.getDisplayName()}&quot;&#10;        updateUIBasedOnRole(state.userRole)&#10;    }&#10;&#10;    private fun updateTesseraInfo(user: com.example.circolapp.domain.model.User) {&#10;        when {&#10;            user.hasTessera &amp;&amp; user.numeroTessera != null -&gt; {&#10;                textTesseraStatus.text = &quot;Tessera Attiva&quot;&#10;                textTesseraStatus.setTextColor(resources.getColor(android.R.color.holo_green_dark))&#10;&#10;                textNumeroTessera.text = &quot;Numero: ${user.numeroTessera}&quot;&#10;                textNumeroTessera.visibility = View.VISIBLE&#10;&#10;                user.dataScadenzaTessera?.let { dataScadenza -&gt;&#10;                    textScadenzaTessera.text = &quot;Scadenza: ${dateFormatter.format(dataScadenza)}&quot;&#10;                    textScadenzaTessera.visibility = View.VISIBLE&#10;&#10;                    // Controlla se la tessera è scaduta&#10;                    if (dataScadenza.before(Date())) {&#10;                        textTesseraStatus.text = &quot;Tessera Scaduta&quot;&#10;                        textTesseraStatus.setTextColor(resources.getColor(android.R.color.holo_red_dark))&#10;                    }&#10;                }&#10;            }&#10;            user.richiestaRinnovoInCorso -&gt; {&#10;                textTesseraStatus.text = &quot;Richiesta in attesa&quot;&#10;                textTesseraStatus.setTextColor(resources.getColor(android.R.color.holo_orange_dark))&#10;                textNumeroTessera.visibility = View.GONE&#10;                textScadenzaTessera.visibility = View.GONE&#10;            }&#10;            else -&gt; {&#10;                textTesseraStatus.text = &quot;Nessuna tessera&quot;&#10;                textTesseraStatus.setTextColor(resources.getColor(android.R.color.darker_gray))&#10;                textNumeroTessera.visibility = View.GONE&#10;                textScadenzaTessera.visibility = View.GONE&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun updateUIBasedOnRole(userRole: UserRole) {&#10;        if (userRole == UserRole.ADMIN) {&#10;            buttonGestisciTessere.visibility = View.VISIBLE&#10;            buttonTessera.visibility = View.GONE&#10;&#10;            // Nascondi anche tutte le informazioni sulla tessera per l'admin&#10;            requireView().findViewById&lt;TextView&gt;(R.id.text_tessera_title)?.visibility = View.GONE&#10;            textTesseraStatus.visibility = View.GONE&#10;            textNumeroTessera.visibility = View.GONE&#10;            textScadenzaTessera.visibility = View.GONE&#10;&#10;            buttonFeedback.text = &quot;Visualizza Feedback Ricevuti&quot;&#10;        } else {&#10;            buttonGestisciTessere.visibility = View.GONE&#10;            buttonTessera.visibility = View.VISIBLE&#10;&#10;            requireView().findViewById&lt;TextView&gt;(R.id.text_tessera_title)?.visibility = View.VISIBLE&#10;            textTesseraStatus.visibility = View.VISIBLE&#10;&#10;            buttonFeedback.text = &quot;Invia Feedback&quot;&#10;        }&#10;    }&#10;&#10;    private fun handleTesseraRequest() {&#10;        val currentState = viewModel.uiState.value&#10;        val user = currentState.user ?: return&#10;&#10;        when {&#10;            user.richiestaRinnovoInCorso -&gt; {&#10;                Toast.makeText(context, &quot;Hai già una richiesta in corso&quot;, Toast.LENGTH_SHORT).show()&#10;            }&#10;            !user.hasTessera -&gt; {&#10;                requestTessera(TipoRichiesta.NUOVA)&#10;            }&#10;            user.dataScadenzaTessera != null &amp;&amp; user.dataScadenzaTessera.before(Date()) -&gt; {&#10;                requestTessera(TipoRichiesta.RINNOVO)&#10;            }&#10;            else -&gt; {&#10;                Toast.makeText(context, &quot;La tua tessera è ancora valida&quot;, Toast.LENGTH_SHORT).show()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun requestTessera(tipo: TipoRichiesta) {&#10;        val user = viewModel.uiState.value.user ?: return&#10;&#10;        lifecycleScope.launch {&#10;            val useCase = RichiediTesseraUseCase(&#10;                UserRepositoryImpl(),&#10;                com.example.circolapp.data.repository.TesseraRepositoryImpl()&#10;            )&#10;&#10;            val result = useCase.execute(user.uid, tipo)&#10;&#10;            result.onSuccess { message -&gt;&#10;                Toast.makeText(context, message, Toast.LENGTH_SHORT).show()&#10;                viewModel.refreshUserData()&#10;            }.onFailure { error -&gt;&#10;                Toast.makeText(context, error.localizedMessage, Toast.LENGTH_SHORT).show()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun handleFeedbackClick() {&#10;        val userRole = viewModel.uiState.value.userRole&#10;&#10;        if (userRole == UserRole.ADMIN) {&#10;            navigateToFeedbackList()&#10;        } else {&#10;            // Implementare dialog feedback per utenti normali&#10;            Toast.makeText(context, &quot;Funzionalità feedback in implementazione&quot;, Toast.LENGTH_SHORT).show()&#10;        }&#10;    }&#10;&#10;    private fun navigateToGestisciTessere() {&#10;        try {&#10;            findNavController().navigate(R.id.gestisciTessereFragment)&#10;        } catch (e: Exception) {&#10;            Toast.makeText(context, &quot;Errore nella navigazione: ${e.message}&quot;, Toast.LENGTH_SHORT).show()&#10;        }&#10;    }&#10;&#10;    private fun navigateToFeedbackList() {&#10;        try {&#10;            findNavController().navigate(R.id.feedbackListFragment)&#10;        } catch (e: Exception) {&#10;            Toast.makeText(context, &quot;Errore nella navigazione: ${e.message}&quot;, Toast.LENGTH_SHORT).show()&#10;        }&#10;    }&#10;&#10;    private fun logout() {&#10;        AuthUI.getInstance().signOut(requireContext()).addOnCompleteListener {&#10;            val intent = Intent(requireContext(), LoginActivity::class.java)&#10;            intent.flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK&#10;            startActivity(intent)&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.circolapp.presentation.fragments&#10;&#10;import android.content.Intent&#10;import android.os.Bundle&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.Button&#10;import android.widget.TextView&#10;import android.widget.Toast&#10;import androidx.fragment.app.Fragment&#10;import androidx.fragment.app.viewModels&#10;import androidx.lifecycle.lifecycleScope&#10;import androidx.navigation.fragment.findNavController&#10;import com.example.circolapp.LoginActivity&#10;import com.example.circolapp.R&#10;import com.example.circolapp.data.repository.UserRepositoryImpl&#10;import com.example.circolapp.data.repository.TesseraRepositoryImpl&#10;import com.example.circolapp.domain.model.TipoRichiesta&#10;import com.example.circolapp.domain.model.UserRole&#10;import com.example.circolapp.domain.usecase.RichiediTesseraUseCase&#10;import com.example.circolapp.presentation.viewmodel.ProfiloViewModel&#10;import com.example.circolapp.presentation.viewmodel.ProfiloViewModelFactory&#10;import com.firebase.ui.auth.AuthUI&#10;import kotlinx.coroutines.launch&#10;import java.text.NumberFormat&#10;import java.text.SimpleDateFormat&#10;import java.util.*&#10;&#10;class ProfiloFragment : Fragment() {&#10;&#10;    private lateinit var textNome: TextView&#10;    private lateinit var textEmail: TextView&#10;    private lateinit var textTelefono: TextView&#10;    private lateinit var textSaldo: TextView&#10;    private lateinit var textRuolo: TextView&#10;    private lateinit var textTesseraStatus: TextView&#10;    private lateinit var textNumeroTessera: TextView&#10;    private lateinit var textScadenzaTessera: TextView&#10;    private lateinit var buttonTessera: Button&#10;    private lateinit var buttonGestisciTessere: Button&#10;    private lateinit var buttonFeedback: Button&#10;&#10;    private val currencyFormatter = NumberFormat.getCurrencyInstance(Locale.ITALY)&#10;    private val dateFormatter = SimpleDateFormat(&quot;dd/MM/yyyy&quot;, Locale.ITALY)&#10;&#10;    private val viewModel: ProfiloViewModel by viewModels {&#10;        ProfiloViewModelFactory(UserRepositoryImpl())&#10;    }&#10;&#10;    override fun onCreateView(&#10;        inflater: LayoutInflater, container: ViewGroup?,&#10;        savedInstanceState: Bundle?&#10;    ): View? {&#10;        val view = inflater.inflate(R.layout.fragment_profilo, container, false)&#10;&#10;        initializeViews(view)&#10;        setupClickListeners()&#10;        observeViewModel()&#10;&#10;        return view&#10;    }&#10;&#10;    private fun initializeViews(view: View) {&#10;        textNome = view.findViewById(R.id.text_nome)&#10;        textEmail = view.findViewById(R.id.text_email)&#10;        textTelefono = view.findViewById(R.id.text_telefono)&#10;        textSaldo = view.findViewById(R.id.text_saldo)&#10;        textRuolo = view.findViewById(R.id.text_ruolo)&#10;        textTesseraStatus = view.findViewById(R.id.text_tessera_status)&#10;        textNumeroTessera = view.findViewById(R.id.text_numero_tessera)&#10;        textScadenzaTessera = view.findViewById(R.id.text_scadenza_tessera)&#10;        buttonTessera = view.findViewById(R.id.buttonTessera)&#10;        buttonGestisciTessere = view.findViewById(R.id.buttonGestisciTessere)&#10;        buttonFeedback = view.findViewById(R.id.buttonFeedback)&#10;    }&#10;&#10;    private fun setupClickListeners() {&#10;        view?.findViewById&lt;Button&gt;(R.id.buttonLogout)?.setOnClickListener {&#10;            logout()&#10;        }&#10;&#10;        buttonFeedback.setOnClickListener {&#10;            handleFeedbackClick()&#10;        }&#10;&#10;        buttonTessera.setOnClickListener {&#10;            handleTesseraRequest()&#10;        }&#10;&#10;        buttonGestisciTessere.setOnClickListener {&#10;            navigateToGestisciTessere()&#10;        }&#10;    }&#10;&#10;    private fun observeViewModel() {&#10;        viewLifecycleOwner.lifecycleScope.launch {&#10;            viewModel.uiState.collect { state -&gt;&#10;                updateUI(state)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun updateUI(state: com.example.circolapp.presentation.viewmodel.ProfiloUiState) {&#10;        if (state.isLoading) {&#10;            // Mostra loading se necessario&#10;            return&#10;        }&#10;&#10;        state.errorMessage?.let { message -&gt;&#10;            Toast.makeText(context, message, Toast.LENGTH_SHORT).show()&#10;            viewModel.clearError()&#10;        }&#10;&#10;        state.user?.let { user -&gt;&#10;            textNome.text = user.nome.ifEmpty { &quot;Nome non disponibile&quot; }&#10;            textEmail.text = &quot;Email non disponibile&quot; // Da implementare se necessario&#10;            textTelefono.text = &quot;Telefono: Non disponibile&quot; // Da implementare se necessario&#10;            textSaldo.text = &quot;Saldo: ${currencyFormatter.format(user.saldo)}&quot;&#10;&#10;            updateTesseraInfo(user)&#10;        }&#10;&#10;        textRuolo.text = &quot;Ruolo: ${state.userRole.getDisplayName()}&quot;&#10;        updateUIBasedOnRole(state.userRole)&#10;    }&#10;&#10;    private fun updateTesseraInfo(user: com.example.circolapp.domain.model.User) {&#10;        when {&#10;            user.hasTessera &amp;&amp; user.numeroTessera != null -&gt; {&#10;                textTesseraStatus.text = &quot;Tessera Attiva&quot;&#10;                textTesseraStatus.setTextColor(resources.getColor(android.R.color.holo_green_dark))&#10;&#10;                textNumeroTessera.text = &quot;Numero: ${user.numeroTessera}&quot;&#10;                textNumeroTessera.visibility = View.VISIBLE&#10;&#10;                user.dataScadenzaTessera?.let { dataScadenza -&gt;&#10;                    textScadenzaTessera.text = &quot;Scadenza: ${dateFormatter.format(dataScadenza)}&quot;&#10;                    textScadenzaTessera.visibility = View.VISIBLE&#10;&#10;                    // Controlla se la tessera è scaduta&#10;                    if (dataScadenza.before(Date())) {&#10;                        textTesseraStatus.text = &quot;Tessera Scaduta&quot;&#10;                        textTesseraStatus.setTextColor(resources.getColor(android.R.color.holo_red_dark))&#10;                    }&#10;                }&#10;            }&#10;            user.richiestaRinnovoInCorso -&gt; {&#10;                textTesseraStatus.text = &quot;Richiesta in attesa&quot;&#10;                textTesseraStatus.setTextColor(resources.getColor(android.R.color.holo_orange_dark))&#10;                textNumeroTessera.visibility = View.GONE&#10;                textScadenzaTessera.visibility = View.GONE&#10;            }&#10;            else -&gt; {&#10;                textTesseraStatus.text = &quot;Nessuna tessera&quot;&#10;                textTesseraStatus.setTextColor(resources.getColor(android.R.color.darker_gray))&#10;                textNumeroTessera.visibility = View.GONE&#10;                textScadenzaTessera.visibility = View.GONE&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun updateUIBasedOnRole(userRole: UserRole) {&#10;        if (userRole == UserRole.ADMIN) {&#10;            buttonGestisciTessere.visibility = View.VISIBLE&#10;            buttonTessera.visibility = View.GONE&#10;&#10;            // Nascondi anche tutte le informazioni sulla tessera per l'admin&#10;            requireView().findViewById&lt;TextView&gt;(R.id.text_tessera_title)?.visibility = View.GONE&#10;            textTesseraStatus.visibility = View.GONE&#10;            textNumeroTessera.visibility = View.GONE&#10;            textScadenzaTessera.visibility = View.GONE&#10;&#10;            buttonFeedback.text = &quot;Visualizza Feedback Ricevuti&quot;&#10;        } else {&#10;            buttonGestisciTessere.visibility = View.GONE&#10;            buttonTessera.visibility = View.VISIBLE&#10;&#10;            requireView().findViewById&lt;TextView&gt;(R.id.text_tessera_title)?.visibility = View.VISIBLE&#10;            textTesseraStatus.visibility = View.VISIBLE&#10;&#10;            buttonFeedback.text = &quot;Invia Feedback&quot;&#10;        }&#10;    }&#10;&#10;    private fun handleTesseraRequest() {&#10;        val currentState = viewModel.uiState.value&#10;        val user = currentState.user ?: return&#10;&#10;        when {&#10;            user.richiestaRinnovoInCorso -&gt; {&#10;                Toast.makeText(context, &quot;Hai già una richiesta in corso&quot;, Toast.LENGTH_SHORT).show()&#10;            }&#10;            !user.hasTessera -&gt; {&#10;                requestTessera(TipoRichiesta.NUOVA)&#10;            }&#10;            user.dataScadenzaTessera != null &amp;&amp; user.dataScadenzaTessera.before(Date()) -&gt; {&#10;                requestTessera(TipoRichiesta.RINNOVO)&#10;            }&#10;            else -&gt; {&#10;                Toast.makeText(context, &quot;La tua tessera è ancora valida&quot;, Toast.LENGTH_SHORT).show()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun requestTessera(tipo: TipoRichiesta) {&#10;        val user = viewModel.uiState.value.user ?: return&#10;&#10;        lifecycleScope.launch {&#10;            val useCase = RichiediTesseraUseCase(&#10;                UserRepositoryImpl(),&#10;                TesseraRepositoryImpl()&#10;            )&#10;&#10;            val result = useCase.execute(user.uid, tipo)&#10;&#10;            result.onSuccess { message -&gt;&#10;                Toast.makeText(context, message, Toast.LENGTH_SHORT).show()&#10;                viewModel.refreshUserData()&#10;            }.onFailure { error -&gt;&#10;                Toast.makeText(context, error.localizedMessage, Toast.LENGTH_SHORT).show()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun handleFeedbackClick() {&#10;        val userRole = viewModel.uiState.value.userRole&#10;&#10;        if (userRole == UserRole.ADMIN) {&#10;            navigateToFeedbackList()&#10;        } else {&#10;            // Implementare dialog feedback per utenti normali&#10;            Toast.makeText(context, &quot;Funzionalità feedback in implementazione&quot;, Toast.LENGTH_SHORT).show()&#10;        }&#10;    }&#10;&#10;    private fun navigateToGestisciTessere() {&#10;        try {&#10;            findNavController().navigate(R.id.gestisciTessereFragment)&#10;        } catch (e: Exception) {&#10;            Toast.makeText(context, &quot;Errore nella navigazione: ${e.message}&quot;, Toast.LENGTH_SHORT).show()&#10;        }&#10;    }&#10;&#10;    private fun navigateToFeedbackList() {&#10;        try {&#10;            findNavController().navigate(R.id.feedbackListFragment)&#10;        } catch (e: Exception) {&#10;            Toast.makeText(context, &quot;Errore nella navigazione: ${e.message}&quot;, Toast.LENGTH_SHORT).show()&#10;        }&#10;    }&#10;&#10;    private fun logout() {&#10;        AuthUI.getInstance().signOut(requireContext()).addOnCompleteListener {&#10;            val intent = Intent(requireContext(), LoginActivity::class.java)&#10;            intent.flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK&#10;            startActivity(intent)&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/circolapp/presentation/viewmodel/EventiViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/circolapp/presentation/viewmodel/EventiViewModel.kt" />
              <option name="updatedContent" value="package com.example.circolapp.presentation.viewmodel&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.ViewModelProvider&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.circolapp.data.repository.EventiRepository&#10;import com.example.circolapp.data.repository.EventiRepositoryImpl&#10;import com.example.circolapp.data.repository.UserRepository&#10;import com.example.circolapp.data.repository.UserRepositoryImpl&#10;import com.example.circolapp.domain.model.Evento&#10;import com.example.circolapp.domain.model.UserRole&#10;import com.google.firebase.auth.FirebaseAuth&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;&#10;data class EventiUiState(&#10;    val isLoading: Boolean = false,&#10;    val eventi: List&lt;Evento&gt; = emptyList(),&#10;    val currentUserRole: UserRole = UserRole.UNKNOWN,&#10;    val currentUserId: String = &quot;&quot;,&#10;    val errorMessage: String? = null,&#10;    val successMessage: String? = null&#10;)&#10;&#10;class EventiViewModel(&#10;    private val eventiRepository: EventiRepository = EventiRepositoryImpl(),&#10;    private val userRepository: UserRepository = UserRepositoryImpl()&#10;) : ViewModel() {&#10;&#10;    private val _uiState = MutableStateFlow(EventiUiState())&#10;    val uiState: StateFlow&lt;EventiUiState&gt; = _uiState.asStateFlow()&#10;&#10;    init {&#10;        loadEvents()&#10;        loadUserData()&#10;    }&#10;&#10;    private fun loadEvents() {&#10;        viewModelScope.launch {&#10;            _uiState.value = _uiState.value.copy(isLoading = true)&#10;            &#10;            try {&#10;                val eventi = eventiRepository.getAllEvents()&#10;                _uiState.value = _uiState.value.copy(&#10;                    isLoading = false,&#10;                    eventi = eventi,&#10;                    errorMessage = null&#10;                )&#10;            } catch (e: Exception) {&#10;                _uiState.value = _uiState.value.copy(&#10;                    isLoading = false,&#10;                    errorMessage = e.localizedMessage&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun loadUserData() {&#10;        viewModelScope.launch {&#10;            val currentUser = FirebaseAuth.getInstance().currentUser&#10;            if (currentUser != null) {&#10;                _uiState.value = _uiState.value.copy(currentUserId = currentUser.uid)&#10;                &#10;                userRepository.getCurrentUserRole().collect { role -&gt;&#10;                    _uiState.value = _uiState.value.copy(currentUserRole = role)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    fun addEvent(evento: Evento) {&#10;        viewModelScope.launch {&#10;            try {&#10;                val success = eventiRepository.addEvent(evento)&#10;                if (success) {&#10;                    _uiState.value = _uiState.value.copy(&#10;                        successMessage = &quot;Evento aggiunto con successo!&quot;&#10;                    )&#10;                    loadEvents() // Ricarica gli eventi&#10;                } else {&#10;                    _uiState.value = _uiState.value.copy(&#10;                        errorMessage = &quot;Errore nell'aggiunta dell'evento&quot;&#10;                    )&#10;                }&#10;            } catch (e: Exception) {&#10;                _uiState.value = _uiState.value.copy(&#10;                    errorMessage = e.localizedMessage&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    fun participaEvento(eventoId: String) {&#10;        viewModelScope.launch {&#10;            try {&#10;                val currentUserId = _uiState.value.currentUserId&#10;                if (currentUserId.isNotEmpty()) {&#10;                    val success = eventiRepository.addParticipant(eventoId, currentUserId)&#10;                    if (success) {&#10;                        _uiState.value = _uiState.value.copy(&#10;                            successMessage = &quot;Partecipazione confermata!&quot;&#10;                        )&#10;                        loadEvents() // Ricarica gli eventi&#10;                    } else {&#10;                        _uiState.value = _uiState.value.copy(&#10;                            errorMessage = &quot;Errore nella partecipazione&quot;&#10;                        )&#10;                    }&#10;                }&#10;            } catch (e: Exception) {&#10;                _uiState.value = _uiState.value.copy(&#10;                    errorMessage = e.localizedMessage&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    fun rimuoviPartecipazione(eventoId: String) {&#10;        viewModelScope.launch {&#10;            try {&#10;                val currentUserId = _uiState.value.currentUserId&#10;                if (currentUserId.isNotEmpty()) {&#10;                    val success = eventiRepository.removeParticipant(eventoId, currentUserId)&#10;                    if (success) {&#10;                        _uiState.value = _uiState.value.copy(&#10;                            successMessage = &quot;Partecipazione rimossa&quot;&#10;                        )&#10;                        loadEvents() // Ricarica gli eventi&#10;                    } else {&#10;                        _uiState.value = _uiState.value.copy(&#10;                            errorMessage = &quot;Errore nella rimozione della partecipazione&quot;&#10;                        )&#10;                    }&#10;                }&#10;            } catch (e: Exception) {&#10;                _uiState.value = _uiState.value.copy(&#10;                    errorMessage = e.localizedMessage&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    fun isUserParticipating(evento: Evento): Boolean {&#10;        val currentUserId = _uiState.value.currentUserId&#10;        return evento.partecipanti.contains(currentUserId)&#10;    }&#10;&#10;    fun canUserParticipate(evento: Evento): Boolean {&#10;        return !isUserParticipating(evento) &amp;&amp; &#10;               evento.partecipanti.size &lt; evento.maxPartecipanti&#10;    }&#10;&#10;    fun clearMessages() {&#10;        _uiState.value = _uiState.value.copy(&#10;            errorMessage = null,&#10;            successMessage = null&#10;        )&#10;    }&#10;&#10;    fun refreshEvents() {&#10;        loadEvents()&#10;    }&#10;}&#10;&#10;class EventiViewModelFactory(&#10;    private val eventiRepository: EventiRepository,&#10;    private val userRepository: UserRepository&#10;) : ViewModelProvider.Factory {&#10;    @Suppress(&quot;UNCHECKED_CAST&quot;)&#10;    override fun &lt;T : ViewModel&gt; create(modelClass: Class&lt;T&gt;): T {&#10;        if (modelClass.isAssignableFrom(EventiViewModel::class.java)) {&#10;            return EventiViewModel(eventiRepository, userRepository) as T&#10;        }&#10;        throw IllegalArgumentException(&quot;Unknown ViewModel class&quot;)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/circolapp/presentation/viewmodel/GestisciTessereViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/circolapp/presentation/viewmodel/GestisciTessereViewModel.kt" />
              <option name="updatedContent" value="package com.example.circolapp.presentation.viewmodel&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.ViewModelProvider&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.circolapp.data.repository.TesseraRepository&#10;import com.example.circolapp.data.repository.TesseraRepositoryImpl&#10;import com.example.circolapp.data.repository.UserRepository&#10;import com.example.circolapp.data.repository.UserRepositoryImpl&#10;import com.example.circolapp.domain.model.RichiestaTessera&#10;import com.example.circolapp.domain.model.TipoRichiesta&#10;import com.example.circolapp.domain.model.User&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;import java.util.*&#10;&#10;data class GestisciTessereUiState(&#10;    val isLoading: Boolean = false,&#10;    val utenti: List&lt;User&gt; = emptyList(),&#10;    val richieste: List&lt;RichiestaTessera&gt; = emptyList(),&#10;    val errorMessage: String? = null,&#10;    val successMessage: String? = null&#10;)&#10;&#10;class GestisciTessereViewModel(&#10;    private val userRepository: UserRepository = UserRepositoryImpl(),&#10;    private val tesseraRepository: TesseraRepository = TesseraRepositoryImpl()&#10;) : ViewModel() {&#10;&#10;    private val _uiState = MutableStateFlow(GestisciTessereUiState())&#10;    val uiState: StateFlow&lt;GestisciTessereUiState&gt; = _uiState.asStateFlow()&#10;&#10;    init {&#10;        loadData()&#10;    }&#10;&#10;    private fun loadData() {&#10;        viewModelScope.launch {&#10;            _uiState.value = _uiState.value.copy(isLoading = true)&#10;            &#10;            try {&#10;                val utenti = userRepository.getAllUsers()&#10;                val richieste = tesseraRepository.getAllRichieste()&#10;                &#10;                _uiState.value = _uiState.value.copy(&#10;                    isLoading = false,&#10;                    utenti = utenti,&#10;                    richieste = richieste,&#10;                    errorMessage = null&#10;                )&#10;            } catch (e: Exception) {&#10;                _uiState.value = _uiState.value.copy(&#10;                    isLoading = false,&#10;                    errorMessage = e.localizedMessage&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    fun approvaRichiesta(utente: User) {&#10;        viewModelScope.launch {&#10;            try {&#10;                // Genera numero tessera e data scadenza&#10;                val numeroTessera = &quot;TS${System.currentTimeMillis().toString().takeLast(8)}&quot;&#10;                val calendar = Calendar.getInstance()&#10;                calendar.add(Calendar.YEAR, 1)&#10;                val dataScadenza = calendar.time&#10;&#10;                // Aggiorna l'utente con la tessera&#10;                val utenteAggiornato = utente.copy(&#10;                    hasTessera = true,&#10;                    numeroTessera = numeroTessera,&#10;                    dataScadenzaTessera = dataScadenza,&#10;                    richiestaRinnovoInCorso = false&#10;                )&#10;&#10;                val success = userRepository.updateUser(utenteAggiornato)&#10;                if (success) {&#10;                    // Rimuovi le richieste dell'utente&#10;                    val richiesteUtente = tesseraRepository.getRichiesteByUser(utente.uid)&#10;                    richiesteUtente.forEach { richiesta -&gt;&#10;                        tesseraRepository.deleteRichiesta(richiesta.id)&#10;                    }&#10;                    &#10;                    _uiState.value = _uiState.value.copy(&#10;                        successMessage = &quot;Tessera assegnata con successo!&quot;&#10;                    )&#10;                    loadData() // Ricarica i dati&#10;                } else {&#10;                    _uiState.value = _uiState.value.copy(&#10;                        errorMessage = &quot;Errore nell'assegnazione della tessera&quot;&#10;                    )&#10;                }&#10;            } catch (e: Exception) {&#10;                _uiState.value = _uiState.value.copy(&#10;                    errorMessage = e.localizedMessage&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    fun rifiutaRichiesta(utente: User) {&#10;        viewModelScope.launch {&#10;            try {&#10;                // Aggiorna l'utente rimuovendo il flag di richiesta in corso&#10;                val utenteAggiornato = utente.copy(richiestaRinnovoInCorso = false)&#10;                &#10;                val success = userRepository.updateUser(utenteAggiornato)&#10;                if (success) {&#10;                    // Rimuovi le richieste dell'utente&#10;                    val richiesteUtente = tesseraRepository.getRichiesteByUser(utente.uid)&#10;                    richiesteUtente.forEach { richiesta -&gt;&#10;                        tesseraRepository.deleteRichiesta(richiesta.id)&#10;                    }&#10;                    &#10;                    _uiState.value = _uiState.value.copy(&#10;                        successMessage = &quot;Richiesta rifiutata&quot;&#10;                    )&#10;                    loadData() // Ricarica i dati&#10;                } else {&#10;                    _uiState.value = _uiState.value.copy(&#10;                        errorMessage = &quot;Errore nel rifiuto della richiesta&quot;&#10;                    )&#10;                }&#10;            } catch (e: Exception) {&#10;                _uiState.value = _uiState.value.copy(&#10;                    errorMessage = e.localizedMessage&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    fun assegnaTessera(utente: User) {&#10;        viewModelScope.launch {&#10;            try {&#10;                val numeroTessera = &quot;TS${System.currentTimeMillis().toString().takeLast(8)}&quot;&#10;                val calendar = Calendar.getInstance()&#10;                calendar.add(Calendar.YEAR, 1)&#10;                val dataScadenza = calendar.time&#10;&#10;                val utenteAggiornato = utente.copy(&#10;                    hasTessera = true,&#10;                    numeroTessera = numeroTessera,&#10;                    dataScadenzaTessera = dataScadenza,&#10;                    richiestaRinnovoInCorso = false&#10;                )&#10;&#10;                val success = userRepository.updateUser(utenteAggiornato)&#10;                if (success) {&#10;                    _uiState.value = _uiState.value.copy(&#10;                        successMessage = &quot;Tessera assegnata!&quot;&#10;                    )&#10;                    loadData()&#10;                } else {&#10;                    _uiState.value = _uiState.value.copy(&#10;                        errorMessage = &quot;Errore nell'assegnazione della tessera&quot;&#10;                    )&#10;                }&#10;            } catch (e: Exception) {&#10;                _uiState.value = _uiState.value.copy(&#10;                    errorMessage = e.localizedMessage&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    fun rinnovaTessera(utente: User) {&#10;        viewModelScope.launch {&#10;            try {&#10;                val calendar = Calendar.getInstance()&#10;                calendar.add(Calendar.YEAR, 1)&#10;                val nuovaDataScadenza = calendar.time&#10;&#10;                val utenteAggiornato = utente.copy(dataScadenzaTessera = nuovaDataScadenza)&#10;&#10;                val success = userRepository.updateUser(utenteAggiornato)&#10;                if (success) {&#10;                    _uiState.value = _uiState.value.copy(&#10;                        successMessage = &quot;Tessera rinnovata!&quot;&#10;                    )&#10;                    loadData()&#10;                } else {&#10;                    _uiState.value = _uiState.value.copy(&#10;                        errorMessage = &quot;Errore nel rinnovo della tessera&quot;&#10;                    )&#10;                }&#10;            } catch (e: Exception) {&#10;                _uiState.value = _uiState.value.copy(&#10;                    errorMessage = e.localizedMessage&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    fun revocaTessera(utente: User) {&#10;        viewModelScope.launch {&#10;            try {&#10;                val utenteAggiornato = utente.copy(&#10;                    hasTessera = false,&#10;                    numeroTessera = null,&#10;                    dataScadenzaTessera = null,&#10;                    richiestaRinnovoInCorso = false&#10;                )&#10;&#10;                val success = userRepository.updateUser(utenteAggiornato)&#10;                if (success) {&#10;                    _uiState.value = _uiState.value.copy(&#10;                        successMessage = &quot;Tessera revocata&quot;&#10;                    )&#10;                    loadData()&#10;                } else {&#10;                    _uiState.value = _uiState.value.copy(&#10;                        errorMessage = &quot;Errore nella revoca della tessera&quot;&#10;                    )&#10;                }&#10;            } catch (e: Exception) {&#10;                _uiState.value = _uiState.value.copy(&#10;                    errorMessage = e.localizedMessage&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    fun clearMessages() {&#10;        _uiState.value = _uiState.value.copy(&#10;            errorMessage = null,&#10;            successMessage = null&#10;        )&#10;    }&#10;&#10;    fun refreshData() {&#10;        loadData()&#10;    }&#10;}&#10;&#10;class GestisciTessereViewModelFactory(&#10;    private val userRepository: UserRepository,&#10;    private val tesseraRepository: TesseraRepository&#10;) : ViewModelProvider.Factory {&#10;    @Suppress(&quot;UNCHECKED_CAST&quot;)&#10;    override fun &lt;T : ViewModel&gt; create(modelClass: Class&lt;T&gt;): T {&#10;        if (modelClass.isAssignableFrom(GestisciTessereViewModel::class.java)) {&#10;            return GestisciTessereViewModel(userRepository, tesseraRepository) as T&#10;        }&#10;        throw IllegalArgumentException(&quot;Unknown ViewModel class&quot;)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/circolapp/presentation/viewmodel/ProductCatalogViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/circolapp/presentation/viewmodel/ProductCatalogViewModel.kt" />
              <option name="updatedContent" value="package com.example.circolapp.presentation.viewmodel&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.ViewModelProvider&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.circolapp.data.repository.ProductRepository&#10;import com.example.circolapp.data.repository.ProductRepositoryImpl&#10;import com.example.circolapp.data.repository.UserRepository&#10;import com.example.circolapp.data.repository.UserRepositoryImpl&#10;import com.example.circolapp.domain.model.Product&#10;import com.example.circolapp.domain.model.UserRole&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;&#10;data class ProductCatalogUiState(&#10;    val isLoading: Boolean = false,&#10;    val products: List&lt;Product&gt; = emptyList(),&#10;    val categories: List&lt;String&gt; = listOf(&quot;Tutte&quot;),&#10;    val selectedCategory: String = &quot;Tutte&quot;,&#10;    val currentUserRole: UserRole = UserRole.UNKNOWN,&#10;    val errorMessage: String? = null&#10;)&#10;&#10;class ProductCatalogViewModel(&#10;    private val productRepository: ProductRepository = ProductRepositoryImpl(),&#10;    private val userRepository: UserRepository = UserRepositoryImpl()&#10;) : ViewModel() {&#10;&#10;    private val _uiState = MutableStateFlow(ProductCatalogUiState())&#10;    val uiState: StateFlow&lt;ProductCatalogUiState&gt; = _uiState.asStateFlow()&#10;&#10;    init {&#10;        loadProducts()&#10;        loadUserRole()&#10;    }&#10;&#10;    private fun loadProducts() {&#10;        viewModelScope.launch {&#10;            _uiState.value = _uiState.value.copy(isLoading = true)&#10;            &#10;            try {&#10;                val products = productRepository.getAllProducts()&#10;                val categories = listOf(&quot;Tutte&quot;) + products.map { it.categoria }.distinct().filter { it.isNotEmpty() }&#10;                &#10;                _uiState.value = _uiState.value.copy(&#10;                    isLoading = false,&#10;                    products = products,&#10;                    categories = categories,&#10;                    errorMessage = null&#10;                )&#10;            } catch (e: Exception) {&#10;                _uiState.value = _uiState.value.copy(&#10;                    isLoading = false,&#10;                    errorMessage = e.localizedMessage&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun loadUserRole() {&#10;        viewModelScope.launch {&#10;            userRepository.getCurrentUserRole().collect { role -&gt;&#10;                _uiState.value = _uiState.value.copy(currentUserRole = role)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun selectCategory(category: String) {&#10;        _uiState.value = _uiState.value.copy(selectedCategory = category)&#10;    }&#10;&#10;    fun getFilteredProducts(): List&lt;Product&gt; {&#10;        val currentState = _uiState.value&#10;        return if (currentState.selectedCategory == &quot;Tutte&quot;) {&#10;            currentState.products&#10;        } else {&#10;            currentState.products.filter { it.categoria == currentState.selectedCategory }&#10;        }&#10;    }&#10;&#10;    fun refreshProducts() {&#10;        loadProducts()&#10;    }&#10;&#10;    fun clearError() {&#10;        _uiState.value = _uiState.value.copy(errorMessage = null)&#10;    }&#10;}&#10;&#10;class ProductCatalogViewModelFactory(&#10;    private val productRepository: ProductRepository,&#10;    private val userRepository: UserRepository&#10;) : ViewModelProvider.Factory {&#10;    @Suppress(&quot;UNCHECKED_CAST&quot;)&#10;    override fun &lt;T : ViewModel&gt; create(modelClass: Class&lt;T&gt;): T {&#10;        if (modelClass.isAssignableFrom(ProductCatalogViewModel::class.java)) {&#10;            return ProductCatalogViewModel(productRepository, userRepository) as T&#10;        }&#10;        throw IllegalArgumentException(&quot;Unknown ViewModel class&quot;)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/circolapp/presentation/viewmodel/ProfiloViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/circolapp/presentation/viewmodel/ProfiloViewModel.kt" />
              <option name="updatedContent" value="package com.example.circolapp.presentation.viewmodel&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.ViewModelProvider&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.circolapp.data.repository.UserRepository&#10;import com.example.circolapp.data.repository.UserRepositoryImpl&#10;import com.example.circolapp.domain.model.User&#10;import com.example.circolapp.domain.model.UserRole&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;&#10;data class ProfiloUiState(&#10;    val isLoading: Boolean = false,&#10;    val user: User? = null,&#10;    val userRole: UserRole = UserRole.UNKNOWN,&#10;    val errorMessage: String? = null&#10;)&#10;&#10;class ProfiloViewModel(&#10;    private val userRepository: UserRepository = UserRepositoryImpl()&#10;) : ViewModel() {&#10;&#10;    private val _uiState = MutableStateFlow(ProfiloUiState())&#10;    val uiState: StateFlow&lt;ProfiloUiState&gt; = _uiState.asStateFlow()&#10;&#10;    init {&#10;        loadUserData()&#10;    }&#10;&#10;    private fun loadUserData() {&#10;        viewModelScope.launch {&#10;            _uiState.value = _uiState.value.copy(isLoading = true)&#10;            &#10;            try {&#10;                val user = userRepository.getCurrentUser()&#10;                userRepository.getCurrentUserRole().collect { role -&gt;&#10;                    _uiState.value = _uiState.value.copy(&#10;                        isLoading = false,&#10;                        user = user,&#10;                        userRole = role,&#10;                        errorMessage = null&#10;                    )&#10;                }&#10;            } catch (e: Exception) {&#10;                _uiState.value = _uiState.value.copy(&#10;                    isLoading = false,&#10;                    errorMessage = e.localizedMessage&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    fun refreshUserData() {&#10;        loadUserData()&#10;    }&#10;&#10;    fun clearError() {&#10;        _uiState.value = _uiState.value.copy(errorMessage = null)&#10;    }&#10;}&#10;&#10;class ProfiloViewModelFactory(&#10;    private val userRepository: UserRepository&#10;) : ViewModelProvider.Factory {&#10;    @Suppress(&quot;UNCHECKED_CAST&quot;)&#10;    override fun &lt;T : ViewModel&gt; create(modelClass: Class&lt;T&gt;): T {&#10;        if (modelClass.isAssignableFrom(ProfiloViewModel::class.java)) {&#10;            return ProfiloViewModel(userRepository) as T&#10;        }&#10;        throw IllegalArgumentException(&quot;Unknown ViewModel class&quot;)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/circolapp/viewmodel/DettaglioProdottoViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/circolapp/viewmodel/DettaglioProdottoViewModel.kt" />
              <option name="originalContent" value="package com.example.circolapp.viewmodel&#10;&#10;import android.app.Application&#10;import android.util.Log&#10;import androidx.lifecycle.AndroidViewModel&#10;import androidx.lifecycle.LiveData&#10;import androidx.lifecycle.MutableLiveData&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.circolapp.model.Product&#10;import com.example.circolapp.model.Ordine&#10;import com.example.circolapp.model.UserRole&#10;import com.google.firebase.auth.FirebaseAuth&#10;import com.google.firebase.firestore.FirebaseFirestore&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.tasks.await&#10;import java.util.*&#10;&#10;data class DettaglioProdottoState(&#10;    val product: Product? = null,&#10;    val isLoading: Boolean = false,&#10;    val errorMessage: String? = null,&#10;    val currentUserRole: UserRole? = null,&#10;    val orderSuccessMessage: String? = null&#10;)&#10;&#10;class DettaglioProdottoViewModel(application: Application) : AndroidViewModel(application) {&#10;&#10;    private val db = FirebaseFirestore.getInstance()&#10;    private val auth = FirebaseAuth.getInstance()&#10;&#10;    private val _state = MutableLiveData(DettaglioProdottoState())&#10;    val state: LiveData&lt;DettaglioProdottoState&gt; get() = _state&#10;&#10;    fun initialize(product: Product) {&#10;        _state.value = _state.value?.copy(product = product, isLoading = true)&#10;        loadUserRole()&#10;    }&#10;&#10;    private fun loadUserRole() {&#10;        viewModelScope.launch {&#10;            try {&#10;                val currentUser = auth.currentUser&#10;                if (currentUser != null) {&#10;                    val userDoc = db.collection(&quot;utenti&quot;).document(currentUser.uid).get().await()&#10;                    val roleString = userDoc.getString(&quot;ruolo&quot;)&#10;                    val role = roleString?.let { UserRole.valueOf(it.uppercase()) }&#10;&#10;                    updateState { it.copy(currentUserRole = role, isLoading = false) }&#10;                } else {&#10;                    updateState { it.copy(isLoading = false, errorMessage = &quot;Utente non autenticato&quot;) }&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;DettaglioProdottoVM&quot;, &quot;Errore caricamento ruolo utente&quot;, e)&#10;                updateState { it.copy(isLoading = false, errorMessage = &quot;Errore caricamento dati utente&quot;) }&#10;            }&#10;        }&#10;    }&#10;&#10;    fun orderProduct(additionalRequests: String) {&#10;        val product = _state.value?.product&#10;        val currentUser = auth.currentUser&#10;&#10;        if (product == null || currentUser == null) {&#10;            updateState { it.copy(errorMessage = &quot;Dati mancanti per completare l'ordine&quot;) }&#10;            return&#10;        }&#10;&#10;        updateState { it.copy(isLoading = true) }&#10;&#10;        viewModelScope.launch {&#10;            try {&#10;                val ordine = Ordine(&#10;                    uidUtente = currentUser.uid,&#10;                    prodottoId = product.id ?: &quot;&quot;,&#10;                    nomeProdotto = product.nome,&#10;                    importo = product.importo,&#10;                    richiesteAggiuntive = additionalRequests,&#10;                    dataOrdine = Date(),&#10;                    stato = &quot;in_attesa&quot;&#10;                )&#10;&#10;                db.collection(&quot;ordinazioni&quot;).add(ordine).await()&#10;&#10;                updateState {&#10;                    it.copy(&#10;                        isLoading = false,&#10;                        orderSuccessMessage = &quot;Ordine effettuato con successo!&quot;,&#10;                        errorMessage = null&#10;                    )&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;DettaglioProdottoVM&quot;, &quot;Errore creazione ordine&quot;, e)&#10;                updateState {&#10;                    it.copy(&#10;                        isLoading = false,&#10;                        errorMessage = &quot;Errore nell'effettuare l'ordine: ${e.message}&quot;&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    fun clearMessages() {&#10;        updateState { it.copy(errorMessage = null, orderSuccessMessage = null) }&#10;    }&#10;&#10;    private fun updateState(updateAction: (DettaglioProdottoState) -&gt; DettaglioProdottoState) {&#10;        _state.value = updateAction(_state.value ?: DettaglioProdottoState())&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.circolapp.viewmodel&#13;&#10;&#13;&#10;import android.app.Application&#13;&#10;import android.util.Log&#13;&#10;import androidx.lifecycle.AndroidViewModel&#13;&#10;import androidx.lifecycle.LiveData&#13;&#10;import androidx.lifecycle.MutableLiveData&#13;&#10;import androidx.lifecycle.viewModelScope&#13;&#10;import com.example.circolapp.model.Product&#13;&#10;import com.example.circolapp.model.Ordine&#13;&#10;import com.example.circolapp.model.UserRole&#13;&#10;import com.google.firebase.auth.FirebaseAuth&#13;&#10;import com.google.firebase.firestore.FirebaseFirestore&#13;&#10;import kotlinx.coroutines.launch&#13;&#10;import kotlinx.coroutines.tasks.await&#13;&#10;import java.util.*&#13;&#10;&#13;&#10;data class DettaglioProdottoState(&#13;&#10;    val product: Product? = null,&#13;&#10;    val isLoading: Boolean = false,&#13;&#10;    val errorMessage: String? = null,&#13;&#10;    val currentUserRole: UserRole? = null,&#13;&#10;    val orderSuccessMessage: String? = null&#13;&#10;)&#13;&#10;&#13;&#10;class DettaglioProdottoViewModel(application: Application) : AndroidViewModel(application) {&#13;&#10;&#13;&#10;    private val db = FirebaseFirestore.getInstance()&#13;&#10;    private val auth = FirebaseAuth.getInstance()&#13;&#10;&#13;&#10;    private val _state = MutableLiveData(DettaglioProdottoState())&#13;&#10;    val state: LiveData&lt;DettaglioProdottoState&gt; get() = _state&#13;&#10;&#13;&#10;    fun initialize(product: Product) {&#13;&#10;        _state.value = _state.value?.copy(product = product, isLoading = true)&#13;&#10;        loadUserRole()&#13;&#10;    }&#13;&#10;&#13;&#10;    private fun loadUserRole() {&#13;&#10;        viewModelScope.launch {&#13;&#10;            try {&#13;&#10;                val currentUser = auth.currentUser&#13;&#10;                if (currentUser != null) {&#13;&#10;                    val userDoc = db.collection(&quot;utenti&quot;).document(currentUser.uid).get().await()&#13;&#10;                    val roleString = userDoc.getString(&quot;ruolo&quot;)&#13;&#10;                    val role = roleString?.let { UserRole.valueOf(it.uppercase()) }&#13;&#10;&#13;&#10;                    updateState { it.copy(currentUserRole = role, isLoading = false) }&#13;&#10;                } else {&#13;&#10;                    updateState { it.copy(isLoading = false, errorMessage = &quot;Utente non autenticato&quot;) }&#13;&#10;                }&#13;&#10;            } catch (e: Exception) {&#13;&#10;                Log.e(&quot;DettaglioProdottoVM&quot;, &quot;Errore caricamento ruolo utente&quot;, e)&#13;&#10;                updateState { it.copy(isLoading = false, errorMessage = &quot;Errore caricamento dati utente&quot;) }&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    fun orderProduct(additionalRequests: String) {&#13;&#10;        val product = _state.value?.product&#13;&#10;        val currentUser = auth.currentUser&#13;&#10;&#13;&#10;        if (product == null || currentUser == null) {&#13;&#10;            updateState { it.copy(errorMessage = &quot;Dati mancanti per completare l'ordine&quot;) }&#13;&#10;            return&#13;&#10;        }&#13;&#10;&#13;&#10;        updateState { it.copy(isLoading = true) }&#13;&#10;&#13;&#10;        viewModelScope.launch {&#13;&#10;            try {&#13;&#10;                val ordine = Ordine(&#13;&#10;                    uidUtente = currentUser.uid,&#13;&#10;                    nomeProdotto = product.nome,&#13;&#10;                    prodottoId = product.id ?: &quot;&quot;,&#13;&#10;                    richiesteAggiuntive = additionalRequests,&#13;&#10;                    timestamp = Date(),&#13;&#10;                    stato = &quot;in_attesa&quot;&#13;&#10;                )&#13;&#10;&#13;&#10;                db.collection(&quot;ordinazioni&quot;).add(ordine).await()&#13;&#10;&#13;&#10;                updateState {&#13;&#10;                    it.copy(&#13;&#10;                        isLoading = false,&#13;&#10;                        orderSuccessMessage = &quot;Ordine effettuato con successo!&quot;,&#13;&#10;                        errorMessage = null&#13;&#10;                    )&#13;&#10;                }&#13;&#10;            } catch (e: Exception) {&#13;&#10;                Log.e(&quot;DettaglioProdottoVM&quot;, &quot;Errore creazione ordine&quot;, e)&#13;&#10;                updateState {&#13;&#10;                    it.copy(&#13;&#10;                        isLoading = false,&#13;&#10;                        errorMessage = &quot;Errore nell'effettuare l'ordine: ${e.message}&quot;&#13;&#10;                    )&#13;&#10;                }&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    fun clearMessages() {&#13;&#10;        updateState { it.copy(errorMessage = null, orderSuccessMessage = null) }&#13;&#10;    }&#13;&#10;&#13;&#10;    private fun updateState(updateAction: (DettaglioProdottoState) -&gt; DettaglioProdottoState) {&#13;&#10;        _state.value = updateAction(_state.value ?: DettaglioProdottoState())&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/circolapp/viewmodel/PagamentoViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/circolapp/viewmodel/PagamentoViewModel.kt" />
              <option name="originalContent" value="package com.example.circolapp.viewmodel&#10;&#10;import android.app.Application&#10;import android.util.Log&#10;import androidx.lifecycle.AndroidViewModel&#10;import androidx.lifecycle.LiveData&#10;import androidx.lifecycle.MutableLiveData&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.circolapp.model.Ordine&#10;import com.google.firebase.auth.FirebaseAuth&#10;import com.google.firebase.firestore.FirebaseFirestore&#10;import com.google.firebase.firestore.FieldValue&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.tasks.await&#10;&#10;data class PagamentoState(&#10;    val ordine: Ordine? = null,&#10;    val saldoUtente: Double = 0.0,&#10;    val isLoading: Boolean = false,&#10;    val errorMessage: String? = null,&#10;    val paymentSuccessMessage: String? = null,&#10;    val insufficientFunds: Boolean = false&#10;)&#10;&#10;class PagamentoViewModel(application: Application) : AndroidViewModel(application) {&#10;&#10;    private val db = FirebaseFirestore.getInstance()&#10;    private val auth = FirebaseAuth.getInstance()&#10;&#10;    private val _state = MutableLiveData(PagamentoState())&#10;    val state: LiveData&lt;PagamentoState&gt; get() = _state&#10;&#10;    fun initialize(ordine: Ordine) {&#10;        _state.value = _state.value?.copy(ordine = ordine, isLoading = true)&#10;        loadUserBalance()&#10;    }&#10;&#10;    private fun loadUserBalance() {&#10;        val currentUser = auth.currentUser&#10;        if (currentUser == null) {&#10;            updateState {&#10;                it.copy(&#10;                    isLoading = false,&#10;                    errorMessage = &quot;Utente non autenticato&quot;&#10;                )&#10;            }&#10;            return&#10;        }&#10;&#10;        viewModelScope.launch {&#10;            try {&#10;                val userDoc = db.collection(&quot;utenti&quot;).document(currentUser.uid).get().await()&#10;                val saldo = userDoc.getDouble(&quot;saldo&quot;) ?: 0.0&#10;&#10;                val ordine = _state.value?.ordine&#10;                val insufficientFunds = ordine?.let { saldo &lt; it.importo } ?: false&#10;&#10;                updateState {&#10;                    it.copy(&#10;                        saldoUtente = saldo,&#10;                        isLoading = false,&#10;                        insufficientFunds = insufficientFunds,&#10;                        errorMessage = null&#10;                    )&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;PagamentoVM&quot;, &quot;Errore caricamento saldo utente&quot;, e)&#10;                updateState {&#10;                    it.copy(&#10;                        isLoading = false,&#10;                        errorMessage = &quot;Errore nel caricamento del saldo: ${e.message}&quot;&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    fun processPayment() {&#10;        val currentUser = auth.currentUser&#10;        val ordine = _state.value?.ordine&#10;        val saldo = _state.value?.saldoUtente&#10;&#10;        if (currentUser == null || ordine == null || saldo == null) {&#10;            updateState { it.copy(errorMessage = &quot;Dati mancanti per completare il pagamento&quot;) }&#10;            return&#10;        }&#10;&#10;        if (saldo &lt; ordine.importo) {&#10;            updateState {&#10;                it.copy(&#10;                    errorMessage = &quot;Saldo insufficiente. Saldo attuale: €$saldo, Importo richiesto: €${ordine.importo}&quot;,&#10;                    insufficientFunds = true&#10;                )&#10;            }&#10;            return&#10;        }&#10;&#10;        updateState { it.copy(isLoading = true) }&#10;&#10;        viewModelScope.launch {&#10;            try {&#10;                // Aggiorna il saldo dell'utente&#10;                db.collection(&quot;utenti&quot;)&#10;                    .document(currentUser.uid)&#10;                    .update(&quot;saldo&quot;, FieldValue.increment(-ordine.importo))&#10;                    .await()&#10;&#10;                // Registra la transazione nei movimenti&#10;                val movimento = hashMapOf(&#10;                    &quot;importo&quot; to -ordine.importo,&#10;                    &quot;descrizione&quot; to &quot;Pagamento per ${ordine.nomeProdotto}&quot;,&#10;                    &quot;data&quot; to FieldValue.serverTimestamp()&#10;                )&#10;&#10;                db.collection(&quot;utenti&quot;)&#10;                    .document(currentUser.uid)&#10;                    .update(&quot;movimenti&quot;, FieldValue.arrayUnion(movimento))&#10;                    .await()&#10;&#10;                // Aggiorna lo stato dell'ordine&#10;                db.collection(&quot;ordinazioni&quot;)&#10;                    .whereEqualTo(&quot;uidUtente&quot;, currentUser.uid)&#10;                    .whereEqualTo(&quot;prodottoId&quot;, ordine.prodottoId)&#10;                    .whereEqualTo(&quot;stato&quot;, &quot;in_attesa&quot;)&#10;                    .get()&#10;                    .await()&#10;                    .documents&#10;                    .firstOrNull()&#10;                    ?.reference&#10;                    ?.update(&quot;stato&quot;, &quot;completato&quot;)&#10;                    ?.await()&#10;&#10;                updateState {&#10;                    it.copy(&#10;                        isLoading = false,&#10;                        paymentSuccessMessage = &quot;Pagamento completato con successo!&quot;,&#10;                        saldoUtente = saldo - ordine.importo,&#10;                        errorMessage = null&#10;                    )&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;PagamentoVM&quot;, &quot;Errore processamento pagamento&quot;, e)&#10;                updateState {&#10;                    it.copy(&#10;                        isLoading = false,&#10;                        errorMessage = &quot;Errore nel processamento del pagamento: ${e.message}&quot;&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    fun clearMessages() {&#10;        updateState { it.copy(errorMessage = null, paymentSuccessMessage = null) }&#10;    }&#10;&#10;    private fun updateState(updateAction: (PagamentoState) -&gt; PagamentoState) {&#10;        _state.value = updateAction(_state.value ?: PagamentoState())&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.circolapp.viewmodel&#10;&#10;import android.app.Application&#10;import android.util.Log&#10;import androidx.lifecycle.AndroidViewModel&#10;import androidx.lifecycle.LiveData&#10;import androidx.lifecycle.MutableLiveData&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.circolapp.model.Ordine&#10;import com.google.firebase.auth.FirebaseAuth&#10;import com.google.firebase.firestore.FirebaseFirestore&#10;import com.google.firebase.firestore.FieldValue&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.tasks.await&#10;&#10;data class PagamentoState(&#10;    val ordine: Ordine? = null,&#10;    val saldoUtente: Double = 0.0,&#10;    val importoTotale: Double? = null,&#10;    val isLoading: Boolean = false,&#10;    val errorMessage: String? = null,&#10;    val paymentSuccessMessage: String? = null,&#10;    val insufficientFunds: Boolean = false&#10;)&#10;&#10;class PagamentoViewModel(application: Application) : AndroidViewModel(application) {&#10;&#10;    private val db = FirebaseFirestore.getInstance()&#10;    private val auth = FirebaseAuth.getInstance()&#10;&#10;    private val _state = MutableLiveData(PagamentoState())&#10;    val state: LiveData&lt;PagamentoState&gt; get() = _state&#10;&#10;    fun initialize(ordine: Ordine) {&#10;        _state.value = _state.value?.copy(ordine = ordine, isLoading = true)&#10;        loadProductPrice(ordine.prodottoId)&#10;    }&#10;&#10;    private fun loadProductPrice(prodottoId: String) {&#10;        viewModelScope.launch {&#10;            try {&#10;                // Carica il prezzo del prodotto&#10;                val productDoc = db.collection(&quot;prodotti&quot;).document(prodottoId).get().await()&#10;                val importo = productDoc.getDouble(&quot;importo&quot;) ?: 0.0&#10;&#10;                updateState {&#10;                    it.copy(importoTotale = importo)&#10;                }&#10;                &#10;                // Ora carica il saldo dell'utente&#10;                loadUserBalance()&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;PagamentoVM&quot;, &quot;Errore caricamento prezzo prodotto&quot;, e)&#10;                updateState {&#10;                    it.copy(&#10;                        isLoading = false,&#10;                        errorMessage = &quot;Errore nel caricamento del prezzo del prodotto: ${e.message}&quot;&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun loadUserBalance() {&#10;        val currentUser = auth.currentUser&#10;        if (currentUser == null) {&#10;            updateState {&#10;                it.copy(&#10;                    isLoading = false,&#10;                    errorMessage = &quot;Utente non autenticato&quot;&#10;                )&#10;            }&#10;            return&#10;        }&#10;&#10;        viewModelScope.launch {&#10;            try {&#10;                val userDoc = db.collection(&quot;utenti&quot;).document(currentUser.uid).get().await()&#10;                val saldo = userDoc.getDouble(&quot;saldo&quot;) ?: 0.0&#10;&#10;                val importoTotale = _state.value?.importoTotale ?: 0.0&#10;                val insufficientFunds = saldo &lt; importoTotale&#10;&#10;                updateState {&#10;                    it.copy(&#10;                        saldoUtente = saldo,&#10;                        isLoading = false,&#10;                        insufficientFunds = insufficientFunds,&#10;                        errorMessage = null&#10;                    )&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;PagamentoVM&quot;, &quot;Errore caricamento saldo utente&quot;, e)&#10;                updateState {&#10;                    it.copy(&#10;                        isLoading = false,&#10;                        errorMessage = &quot;Errore nel caricamento del saldo: ${e.message}&quot;&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    fun processPayment() {&#10;        val currentUser = auth.currentUser&#10;        val ordine = _state.value?.ordine&#10;        val saldo = _state.value?.saldoUtente&#10;        val importoTotale = _state.value?.importoTotale&#10;&#10;        if (currentUser == null || ordine == null || saldo == null || importoTotale == null) {&#10;            updateState { it.copy(errorMessage = &quot;Dati mancanti per completare il pagamento&quot;) }&#10;            return&#10;        }&#10;&#10;        if (saldo &lt; importoTotale) {&#10;            updateState {&#10;                it.copy(&#10;                    errorMessage = &quot;Saldo insufficiente. Saldo attuale: €$saldo, Importo richiesto: €$importoTotale&quot;,&#10;                    insufficientFunds = true&#10;                )&#10;            }&#10;            return&#10;        }&#10;&#10;        updateState { it.copy(isLoading = true) }&#10;&#10;        viewModelScope.launch {&#10;            try {&#10;                // Aggiorna il saldo dell'utente&#10;                db.collection(&quot;utenti&quot;)&#10;                    .document(currentUser.uid)&#10;                    .update(&quot;saldo&quot;, FieldValue.increment(-importoTotale))&#10;                    .await()&#10;&#10;                // Registra la transazione nei movimenti&#10;                val movimento = hashMapOf(&#10;                    &quot;importo&quot; to -importoTotale,&#10;                    &quot;descrizione&quot; to &quot;Pagamento per ${ordine.nomeProdotto}&quot;,&#10;                    &quot;data&quot; to FieldValue.serverTimestamp()&#10;                )&#10;&#10;                db.collection(&quot;utenti&quot;)&#10;                    .document(currentUser.uid)&#10;                    .update(&quot;movimenti&quot;, FieldValue.arrayUnion(movimento))&#10;                    .await()&#10;&#10;                // Aggiorna lo stato dell'ordine&#10;                db.collection(&quot;ordinazioni&quot;)&#10;                    .whereEqualTo(&quot;uidUtente&quot;, currentUser.uid)&#10;                    .whereEqualTo(&quot;prodottoId&quot;, ordine.prodottoId)&#10;                    .whereEqualTo(&quot;stato&quot;, &quot;in_attesa&quot;)&#10;                    .get()&#10;                    .await()&#10;                    .documents&#10;                    .firstOrNull()&#10;                    ?.reference&#10;                    ?.update(&quot;stato&quot;, &quot;completato&quot;)&#10;                    ?.await()&#10;&#10;                updateState {&#10;                    it.copy(&#10;                        isLoading = false,&#10;                        paymentSuccessMessage = &quot;Pagamento completato con successo!&quot;,&#10;                        saldoUtente = saldo - importoTotale,&#10;                        errorMessage = null&#10;                    )&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;PagamentoVM&quot;, &quot;Errore processamento pagamento&quot;, e)&#10;                updateState {&#10;                    it.copy(&#10;                        isLoading = false,&#10;                        errorMessage = &quot;Errore nel processamento del pagamento: ${e.message}&quot;&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    fun clearMessages() {&#10;        updateState { it.copy(errorMessage = null, paymentSuccessMessage = null) }&#10;    }&#10;&#10;    private fun updateState(updateAction: (PagamentoState) -&gt; PagamentoState) {&#10;        _state.value = updateAction(_state.value ?: PagamentoState())&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/circolapp/viewmodel/ProfiloViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/circolapp/viewmodel/ProfiloViewModel.kt" />
              <option name="originalContent" value="package com.example.circolapp.viewmodel&#10;&#10;import android.app.Application&#10;import android.util.Log&#10;import androidx.lifecycle.AndroidViewModel&#10;import androidx.lifecycle.LiveData&#10;import androidx.lifecycle.MutableLiveData&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.circolapp.model.User&#10;import com.example.circolapp.model.Movimento&#10;import com.google.firebase.auth.FirebaseAuth&#10;import com.google.firebase.firestore.FirebaseFirestore&#10;import com.google.firebase.firestore.ktx.toObject&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.tasks.await&#10;&#10;data class ProfiloState(&#10;    val user: User? = null,&#10;    val movimenti: List&lt;Movimento&gt; = emptyList(),&#10;    val isLoading: Boolean = false,&#10;    val errorMessage: String? = null,&#10;    val successMessage: String? = null&#10;)&#10;&#10;class ProfiloViewModel(application: Application) : AndroidViewModel(application) {&#10;&#10;    private val db = FirebaseFirestore.getInstance()&#10;    private val auth = FirebaseAuth.getInstance()&#10;&#10;    private val _state = MutableLiveData(ProfiloState())&#10;    val state: LiveData&lt;ProfiloState&gt; get() = _state&#10;&#10;    init {&#10;        loadUserProfile()&#10;    }&#10;&#10;    private fun loadUserProfile() {&#10;        val currentUser = auth.currentUser&#10;        if (currentUser == null) {&#10;            updateState {&#10;                it.copy(&#10;                    isLoading = false,&#10;                    errorMessage = &quot;Utente non autenticato&quot;&#10;                )&#10;            }&#10;            return&#10;        }&#10;&#10;        _state.value = _state.value?.copy(isLoading = true)&#10;&#10;        viewModelScope.launch {&#10;            try {&#10;                val userDoc = db.collection(&quot;utenti&quot;).document(currentUser.uid).get().await()&#10;                val user = userDoc.toObject&lt;User&gt;()?.copy(uid = currentUser.uid)&#10;&#10;                // Carica movimenti se presenti&#10;                val movimentiList = userDoc.get(&quot;movimenti&quot;) as? List&lt;Map&lt;String, Any&gt;&gt;&#10;                val movimenti = movimentiList?.mapNotNull { movimentoMap -&gt;&#10;                    try {&#10;                        Movimento(&#10;                            importo = (movimentoMap[&quot;importo&quot;] as? Number)?.toDouble() ?: 0.0,&#10;                            descrizione = movimentoMap[&quot;descrizione&quot;] as? String ?: &quot;&quot;,&#10;                            data = movimentoMap[&quot;data&quot;] as? com.google.firebase.Timestamp&#10;                        )&#10;                    } catch (e: Exception) {&#10;                        null&#10;                    }&#10;                } ?: emptyList()&#10;&#10;                updateState {&#10;                    it.copy(&#10;                        user = user,&#10;                        movimenti = movimenti,&#10;                        isLoading = false,&#10;                        errorMessage = null&#10;                    )&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;ProfiloVM&quot;, &quot;Errore caricamento profilo utente&quot;, e)&#10;                updateState {&#10;                    it.copy(&#10;                        isLoading = false,&#10;                        errorMessage = &quot;Errore nel caricamento del profilo: ${e.message}&quot;&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    fun updateProfile(displayName: String, email: String) {&#10;        val currentUser = auth.currentUser&#10;        if (currentUser == null) {&#10;            updateState { it.copy(errorMessage = &quot;Utente non autenticato&quot;) }&#10;            return&#10;        }&#10;&#10;        updateState { it.copy(isLoading = true) }&#10;&#10;        viewModelScope.launch {&#10;            try {&#10;                // Aggiorna in Firestore&#10;                db.collection(&quot;utenti&quot;)&#10;                    .document(currentUser.uid)&#10;                    .update(&#10;                        mapOf(&#10;                            &quot;displayName&quot; to displayName,&#10;                            &quot;email&quot; to email&#10;                        )&#10;                    )&#10;                    .await()&#10;&#10;                // Aggiorna Firebase Auth se necessario&#10;                if (currentUser.email != email) {&#10;                    currentUser.updateEmail(email).await()&#10;                }&#10;&#10;                updateState {&#10;                    it.copy(&#10;                        isLoading = false,&#10;                        successMessage = &quot;Profilo aggiornato con successo&quot;&#10;                    )&#10;                }&#10;&#10;                // Ricarica il profilo per mostrare i dati aggiornati&#10;                loadUserProfile()&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;ProfiloVM&quot;, &quot;Errore aggiornamento profilo&quot;, e)&#10;                updateState {&#10;                    it.copy(&#10;                        isLoading = false,&#10;                        errorMessage = &quot;Errore nell'aggiornamento del profilo: ${e.message}&quot;&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    fun refreshProfile() {&#10;        loadUserProfile()&#10;    }&#10;&#10;    fun clearMessages() {&#10;        updateState { it.copy(errorMessage = null, successMessage = null) }&#10;    }&#10;&#10;    private fun updateState(updateAction: (ProfiloState) -&gt; ProfiloState) {&#10;        _state.value = updateAction(_state.value ?: ProfiloState())&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.circolapp.viewmodel&#13;&#10;&#13;&#10;import android.app.Application&#13;&#10;import android.util.Log&#13;&#10;import androidx.lifecycle.AndroidViewModel&#13;&#10;import androidx.lifecycle.LiveData&#13;&#10;import androidx.lifecycle.MutableLiveData&#13;&#10;import androidx.lifecycle.viewModelScope&#13;&#10;import com.example.circolapp.model.User&#13;&#10;import com.example.circolapp.model.Movimento&#13;&#10;import com.google.firebase.auth.FirebaseAuth&#13;&#10;import com.google.firebase.firestore.FirebaseFirestore&#13;&#10;import com.google.firebase.firestore.ktx.toObject&#13;&#10;import kotlinx.coroutines.launch&#13;&#10;import kotlinx.coroutines.tasks.await&#13;&#10;&#13;&#10;data class ProfiloState(&#13;&#10;    val user: User? = null,&#13;&#10;    val movimenti: List&lt;Movimento&gt; = emptyList(),&#13;&#10;    val isLoading: Boolean = false,&#13;&#10;    val errorMessage: String? = null,&#13;&#10;    val successMessage: String? = null&#13;&#10;)&#13;&#10;&#13;&#10;class ProfiloViewModel(application: Application) : AndroidViewModel(application) {&#13;&#10;&#13;&#10;    private val db = FirebaseFirestore.getInstance()&#13;&#10;    private val auth = FirebaseAuth.getInstance()&#13;&#10;&#13;&#10;    private val _state = MutableLiveData(ProfiloState())&#13;&#10;    val state: LiveData&lt;ProfiloState&gt; get() = _state&#13;&#10;&#13;&#10;    init {&#13;&#10;        loadUserProfile()&#13;&#10;    }&#13;&#10;&#13;&#10;    private fun loadUserProfile() {&#13;&#10;        val currentUser = auth.currentUser&#13;&#10;        if (currentUser == null) {&#13;&#10;            updateState {&#13;&#10;                it.copy(&#13;&#10;                    isLoading = false,&#13;&#10;                    errorMessage = &quot;Utente non autenticato&quot;&#13;&#10;                )&#13;&#10;            }&#13;&#10;            return&#13;&#10;        }&#13;&#10;&#13;&#10;        _state.value = _state.value?.copy(isLoading = true)&#13;&#10;&#13;&#10;        viewModelScope.launch {&#13;&#10;            try {&#13;&#10;                val userDoc = db.collection(&quot;utenti&quot;).document(currentUser.uid).get().await()&#13;&#10;                val user = userDoc.toObject&lt;User&gt;()?.copy(uid = currentUser.uid)&#13;&#10;&#13;&#10;                // Carica movimenti se presenti&#13;&#10;                val movimentiList = userDoc.get(&quot;movimenti&quot;) as? List&lt;Map&lt;String, Any&gt;&gt;&#13;&#10;                val movimenti = movimentiList?.mapNotNull { movimentoMap -&gt;&#13;&#10;                    try {&#13;&#10;                        val timestamp = movimentoMap[&quot;data&quot;] as? com.google.firebase.Timestamp&#13;&#10;                        Movimento(&#13;&#10;                            importo = (movimentoMap[&quot;importo&quot;] as? Number)?.toDouble() ?: 0.0,&#13;&#10;                            descrizione = movimentoMap[&quot;descrizione&quot;] as? String ?: &quot;&quot;,&#13;&#10;                            data = timestamp?.toDate() // Converte Timestamp in Date&#13;&#10;                        )&#13;&#10;                    } catch (e: Exception) {&#13;&#10;                        null&#13;&#10;                    }&#13;&#10;                } ?: emptyList()&#13;&#10;&#13;&#10;                updateState {&#13;&#10;                    it.copy(&#13;&#10;                        user = user,&#13;&#10;                        movimenti = movimenti,&#13;&#10;                        isLoading = false,&#13;&#10;                        errorMessage = null&#13;&#10;                    )&#13;&#10;                }&#13;&#10;            } catch (e: Exception) {&#13;&#10;                Log.e(&quot;ProfiloVM&quot;, &quot;Errore caricamento profilo utente&quot;, e)&#13;&#10;                updateState {&#13;&#10;                    it.copy(&#13;&#10;                        isLoading = false,&#13;&#10;                        errorMessage = &quot;Errore nel caricamento del profilo: ${e.message}&quot;&#13;&#10;                    )&#13;&#10;                }&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    fun updateProfile(displayName: String, email: String) {&#13;&#10;        val currentUser = auth.currentUser&#13;&#10;        if (currentUser == null) {&#13;&#10;            updateState { it.copy(errorMessage = &quot;Utente non autenticato&quot;) }&#13;&#10;            return&#13;&#10;        }&#13;&#10;&#13;&#10;        updateState { it.copy(isLoading = true) }&#13;&#10;&#13;&#10;        viewModelScope.launch {&#13;&#10;            try {&#13;&#10;                // Aggiorna in Firestore&#13;&#10;                db.collection(&quot;utenti&quot;)&#13;&#10;                    .document(currentUser.uid)&#13;&#10;                    .update(&#13;&#10;                        mapOf(&#13;&#10;                            &quot;displayName&quot; to displayName,&#13;&#10;                            &quot;email&quot; to email&#13;&#10;                        )&#13;&#10;                    )&#13;&#10;                    .await()&#13;&#10;&#13;&#10;                // Aggiorna Firebase Auth se necessario&#13;&#10;                if (currentUser.email != email) {&#13;&#10;                    currentUser.updateEmail(email).await()&#13;&#10;                }&#13;&#10;&#13;&#10;                updateState {&#13;&#10;                    it.copy(&#13;&#10;                        isLoading = false,&#13;&#10;                        successMessage = &quot;Profilo aggiornato con successo&quot;&#13;&#10;                    )&#13;&#10;                }&#13;&#10;&#13;&#10;                // Ricarica il profilo per mostrare i dati aggiornati&#13;&#10;                loadUserProfile()&#13;&#10;            } catch (e: Exception) {&#13;&#10;                Log.e(&quot;ProfiloVM&quot;, &quot;Errore aggiornamento profilo&quot;, e)&#13;&#10;                updateState {&#13;&#10;                    it.copy(&#13;&#10;                        isLoading = false,&#13;&#10;                        errorMessage = &quot;Errore nell'aggiornamento del profilo: ${e.message}&quot;&#13;&#10;                    )&#13;&#10;                }&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    fun refreshProfile() {&#13;&#10;        loadUserProfile()&#13;&#10;    }&#13;&#10;&#13;&#10;    fun clearMessages() {&#13;&#10;        updateState { it.copy(errorMessage = null, successMessage = null) }&#13;&#10;    }&#13;&#10;&#13;&#10;    private fun updateState(updateAction: (ProfiloState) -&gt; ProfiloState) {&#13;&#10;        _state.value = updateAction(_state.value ?: ProfiloState())&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/circolapp/viewmodel/RicaricaViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/circolapp/viewmodel/RicaricaViewModel.kt" />
              <option name="updatedContent" value="package com.example.circolapp.viewmodel&#10;&#10;import android.app.Application&#10;import android.util.Log&#10;import androidx.lifecycle.AndroidViewModel&#10;import androidx.lifecycle.LiveData&#10;import androidx.lifecycle.MutableLiveData&#10;import androidx.lifecycle.viewModelScope&#10;import com.google.firebase.auth.FirebaseAuth&#10;import com.google.firebase.firestore.FirebaseFirestore&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.tasks.await&#10;&#10;data class RicaricaState(&#10;    val username: String = &quot;&quot;,&#10;    val importo: String = &quot;&quot;,&#10;    val isLoading: Boolean = false,&#10;    val errorMessage: String? = null,&#10;    val successMessage: String? = null&#10;)&#10;&#10;class RicaricaViewModel(application: Application) : AndroidViewModel(application) {&#10;&#10;    private val db = FirebaseFirestore.getInstance()&#10;    private val auth = FirebaseAuth.getInstance()&#10;&#10;    private val _state = MutableLiveData(RicaricaState())&#10;    val state: LiveData&lt;RicaricaState&gt; get() = _state&#10;&#10;    fun setScannedCode(code: String) {&#10;        updateState { it.copy(username = code) }&#10;    }&#10;&#10;    fun setImporto(importo: String) {&#10;        updateState { it.copy(importo = importo) }&#10;    }&#10;&#10;    fun confermaRicarica() {&#10;        val currentState = _state.value ?: return&#10;        if (currentState.username.isEmpty() || currentState.importo.isEmpty()) {&#10;            updateState { it.copy(errorMessage = &quot;Inserisci username e importo&quot;) }&#10;            return&#10;        }&#10;&#10;        val importoValue = currentState.importo.toDoubleOrNull()&#10;        if (importoValue == null || importoValue &lt;= 0) {&#10;            updateState { it.copy(errorMessage = &quot;Importo non valido&quot;) }&#10;            return&#10;        }&#10;&#10;        updateState { it.copy(isLoading = true) }&#10;&#10;        viewModelScope.launch {&#10;            try {&#10;                // Trova l'utente e aggiorna il saldo&#10;                val userQuery = db.collection(&quot;utenti&quot;)&#10;                    .whereEqualTo(&quot;uid&quot;, currentState.username)&#10;                    .get()&#10;                    .await()&#10;&#10;                if (userQuery.documents.isEmpty()) {&#10;                    updateState {&#10;                        it.copy(&#10;                            isLoading = false,&#10;                            errorMessage = &quot;Utente non trovato&quot;&#10;                        )&#10;                    }&#10;                    return@launch&#10;                }&#10;&#10;                val userDoc = userQuery.documents.first()&#10;                val currentSaldo = userDoc.getDouble(&quot;saldo&quot;) ?: 0.0&#10;                val newSaldo = currentSaldo + importoValue&#10;&#10;                // Aggiorna il saldo&#10;                userDoc.reference.update(&quot;saldo&quot;, newSaldo).await()&#10;&#10;                // Registra la transazione&#10;                val movimento = hashMapOf(&#10;                    &quot;importo&quot; to importoValue,&#10;                    &quot;descrizione&quot; to &quot;Ricarica in cassa&quot;,&#10;                    &quot;data&quot; to com.google.firebase.firestore.FieldValue.serverTimestamp()&#10;                )&#10;&#10;                userDoc.reference.update(&#10;                    &quot;movimenti&quot;,&#10;                    com.google.firebase.firestore.FieldValue.arrayUnion(movimento)&#10;                ).await()&#10;&#10;                updateState {&#10;                    it.copy(&#10;                        isLoading = false,&#10;                        successMessage = &quot;Ricarica completata con successo!&quot;,&#10;                        errorMessage = null&#10;                    )&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;RicaricaVM&quot;, &quot;Errore ricarica&quot;, e)&#10;                updateState {&#10;                    it.copy(&#10;                        isLoading = false,&#10;                        errorMessage = &quot;Errore durante la ricarica: ${e.message}&quot;&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    fun clearMessages() {&#10;        updateState { it.copy(errorMessage = null, successMessage = null) }&#10;    }&#10;&#10;    fun resetForm() {&#10;        _state.value = RicaricaState()&#10;    }&#10;&#10;    private fun updateState(updateAction: (RicaricaState) -&gt; RicaricaState) {&#10;        _state.value = updateAction(_state.value ?: RicaricaState())&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/drawable/card_background.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/drawable/card_background.xml" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    android:shape=&quot;rectangle&quot;&gt;&#10;    &#10;    &lt;solid android:color=&quot;@android:color/white&quot; /&gt;&#10;    &#10;    &lt;stroke&#10;        android:width=&quot;1dp&quot;&#10;        android:color=&quot;#E0E0E0&quot; /&gt;&#10;    &#10;    &lt;corners android:radius=&quot;12dp&quot; /&gt;&#10;    &#10;    &lt;padding&#10;        android:left=&quot;16dp&quot;&#10;        android:top=&quot;16dp&quot;&#10;        android:right=&quot;16dp&quot;&#10;        android:bottom=&quot;16dp&quot; /&gt;&#10;        &#10;&lt;/shape&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/drawable/edittext_border.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/drawable/edittext_border.xml" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    android:shape=&quot;rectangle&quot;&gt;&#10;    &#10;    &lt;solid android:color=&quot;@android:color/white&quot; /&gt;&#10;    &#10;    &lt;stroke&#10;        android:width=&quot;1dp&quot;&#10;        android:color=&quot;#CCCCCC&quot; /&gt;&#10;    &#10;    &lt;corners android:radius=&quot;8dp&quot; /&gt;&#10;    &#10;    &lt;padding&#10;        android:left=&quot;12dp&quot;&#10;        android:top=&quot;8dp&quot;&#10;        android:right=&quot;12dp&quot;&#10;        android:bottom=&quot;8dp&quot; /&gt;&#10;        &#10;&lt;/shape&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/layout/dialog_gestisci_tessera.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/layout/dialog_gestisci_tessera.xml" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    android:layout_width=&quot;match_parent&quot;&#10;    android:layout_height=&quot;wrap_content&quot;&#10;    android:orientation=&quot;vertical&quot;&#10;    android:padding=&quot;16dp&quot;&gt;&#10;&#10;    &lt;!-- Informazioni Utente --&gt;&#10;    &lt;TextView&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:text=&quot;Informazioni Utente&quot;&#10;        android:textSize=&quot;16sp&quot;&#10;        android:textStyle=&quot;bold&quot;&#10;        android:layout_marginBottom=&quot;8dp&quot;/&gt;&#10;&#10;    &lt;TextView&#10;        android:id=&quot;@+id/text_nome_utente&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:text=&quot;Nome Utente&quot;&#10;        android:textSize=&quot;14sp&quot;&#10;        android:layout_marginBottom=&quot;4dp&quot;/&gt;&#10;&#10;    &lt;TextView&#10;        android:id=&quot;@+id/text_uid_utente&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:text=&quot;UID: xxxxx&quot;&#10;        android:textSize=&quot;12sp&quot;&#10;        android:textColor=&quot;@android:color/darker_gray&quot;&#10;        android:layout_marginBottom=&quot;4dp&quot;/&gt;&#10;&#10;    &lt;TextView&#10;        android:id=&quot;@+id/text_saldo_utente&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:text=&quot;Saldo: €0,00&quot;&#10;        android:textSize=&quot;14sp&quot;&#10;        android:layout_marginBottom=&quot;16dp&quot;/&gt;&#10;&#10;    &lt;!-- Stato Tessera --&gt;&#10;    &lt;TextView&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:text=&quot;Stato Tessera&quot;&#10;        android:textSize=&quot;16sp&quot;&#10;        android:textStyle=&quot;bold&quot;&#10;        android:layout_marginBottom=&quot;8dp&quot;/&gt;&#10;&#10;    &lt;TextView&#10;        android:id=&quot;@+id/text_stato_tessera&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:text=&quot;⚪ Nessuna tessera&quot;&#10;        android:textSize=&quot;14sp&quot;&#10;        android:layout_marginBottom=&quot;4dp&quot;/&gt;&#10;&#10;    &lt;TextView&#10;        android:id=&quot;@+id/text_dettagli_tessera&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:text=&quot;Dettagli tessera&quot;&#10;        android:textSize=&quot;12sp&quot;&#10;        android:textColor=&quot;@android:color/darker_gray&quot;&#10;        android:layout_marginBottom=&quot;16dp&quot;/&gt;&#10;&#10;    &lt;!-- Container per i pulsanti dinamici --&gt;&#10;    &lt;LinearLayout&#10;        android:id=&quot;@+id/button_container&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:orientation=&quot;vertical&quot;&#10;        android:gravity=&quot;center&quot;/&gt;&#10;&#10;&lt;/LinearLayout&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/layout/item_product_simple.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/layout/item_product_simple.xml" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    android:layout_width=&quot;match_parent&quot;&#10;    android:layout_height=&quot;wrap_content&quot;&#10;    android:orientation=&quot;horizontal&quot;&#10;    android:padding=&quot;12dp&quot;&#10;    android:background=&quot;?attr/selectableItemBackground&quot;&gt;&#10;&#10;    &lt;TextView&#10;        android:id=&quot;@+id/textProductName&quot;&#10;        android:layout_width=&quot;0dp&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:layout_weight=&quot;1&quot;&#10;        android:text=&quot;Nome Prodotto&quot;&#10;        android:textSize=&quot;16sp&quot;&#10;        android:textStyle=&quot;bold&quot; /&gt;&#10;&#10;    &lt;TextView&#10;        android:id=&quot;@+id/textProductPrice&quot;&#10;        android:layout_width=&quot;wrap_content&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:text=&quot;€0.00&quot;&#10;        android:textSize=&quot;14sp&quot;&#10;        android:textColor=&quot;#4CAF50&quot;&#10;        android:layout_marginStart=&quot;8dp&quot; /&gt;&#10;&#10;&lt;/LinearLayout&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>